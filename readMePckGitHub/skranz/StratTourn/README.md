


<!DOCTYPE html>
<html lang="en" class="">
  <head prefix="og: http://ogp.me/ns# fb: http://ogp.me/ns/fb# object: http://ogp.me/ns/object# article: http://ogp.me/ns/article# profile: http://ogp.me/ns/profile#">
    <meta charset='utf-8'>
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta http-equiv="Content-Language" content="en">
    
    
    <title>StratTourn/README.md at master · skranz/StratTourn · GitHub</title>
    <link rel="search" type="application/opensearchdescription+xml" href="/opensearch.xml" title="GitHub">
    <link rel="fluid-icon" href="https://github.com/fluidicon.png" title="GitHub">
    <link rel="apple-touch-icon" sizes="57x57" href="/apple-touch-icon-114.png">
    <link rel="apple-touch-icon" sizes="114x114" href="/apple-touch-icon-114.png">
    <link rel="apple-touch-icon" sizes="72x72" href="/apple-touch-icon-144.png">
    <link rel="apple-touch-icon" sizes="144x144" href="/apple-touch-icon-144.png">
    <meta property="fb:app_id" content="1401488693436528">

      <meta content="@github" name="twitter:site" /><meta content="summary" name="twitter:card" /><meta content="skranz/StratTourn" name="twitter:title" /><meta content="StratTourn - Tournament of game theoretic strategies" name="twitter:description" /><meta content="https://avatars2.githubusercontent.com/u/1413022?v=3&amp;s=400" name="twitter:image:src" />
      <meta content="GitHub" property="og:site_name" /><meta content="object" property="og:type" /><meta content="https://avatars2.githubusercontent.com/u/1413022?v=3&amp;s=400" property="og:image" /><meta content="skranz/StratTourn" property="og:title" /><meta content="https://github.com/skranz/StratTourn" property="og:url" /><meta content="StratTourn - Tournament of game theoretic strategies" property="og:description" />
      <meta name="browser-stats-url" content="/_stats">
    <link rel="assets" href="https://assets-cdn.github.com/">
    
    <meta name="pjax-timeout" content="1000">
    

    <meta name="msapplication-TileImage" content="/windows-tile.png">
    <meta name="msapplication-TileColor" content="#ffffff">
    <meta name="selected-link" value="repo_source" data-pjax-transient>
      <meta name="google-analytics" content="UA-3769691-2">

    <meta content="collector.githubapp.com" name="octolytics-host" /><meta content="collector-cdn.github.com" name="octolytics-script-host" /><meta content="github" name="octolytics-app-id" /><meta content="C1BEC102:452A:DF3CB0:55103830" name="octolytics-dimension-request_id" />
    
    <meta content="Rails, view, blob#show" name="analytics-event" />

    
    <link rel="icon" type="image/x-icon" href="https://assets-cdn.github.com/favicon.ico">


    <meta content="authenticity_token" name="csrf-param" />
<meta content="9FSmvRnuBh5Qu5t+HgSnXc/+ZLLykbgeZtavlLxMotiWFydsJJ0FSjPvPEsWIej2BpoXDsDGNuOFwA+Z+bWcjA==" name="csrf-token" />

    <link href="https://assets-cdn.github.com/assets/github-099e0ecc2851c8aca89ef6dafa191df3b0f2a2c8ad34e134c5473ca1ba0a59b2.css" media="all" rel="stylesheet" />
    <link href="https://assets-cdn.github.com/assets/github2-1171344316fc088255ee2a06c271d14240f1a4e06985fe9e897762947872e858.css" media="all" rel="stylesheet" />
    
    


    <meta http-equiv="x-pjax-version" content="c0f32272c66bfb10ed7d46b7c88c6299">

      
  <meta name="description" content="StratTourn - Tournament of game theoretic strategies">
  <meta name="go-import" content="github.com/skranz/StratTourn git https://github.com/skranz/StratTourn.git">

  <meta content="1413022" name="octolytics-dimension-user_id" /><meta content="skranz" name="octolytics-dimension-user_login" /><meta content="13653524" name="octolytics-dimension-repository_id" /><meta content="skranz/StratTourn" name="octolytics-dimension-repository_nwo" /><meta content="true" name="octolytics-dimension-repository_public" /><meta content="false" name="octolytics-dimension-repository_is_fork" /><meta content="13653524" name="octolytics-dimension-repository_network_root_id" /><meta content="skranz/StratTourn" name="octolytics-dimension-repository_network_root_nwo" />
  <link href="https://github.com/skranz/StratTourn/commits/master.atom" rel="alternate" title="Recent Commits to StratTourn:master" type="application/atom+xml">

  </head>


  <body class="logged_out  env-production  vis-public page-blob">
    <a href="#start-of-content" tabindex="1" class="accessibility-aid js-skip-to-content">Skip to content</a>
    <div class="wrapper">
      
      
      


        
        <div class="header header-logged-out" role="banner">
  <div class="container clearfix">

    <a class="header-logo-wordmark" href="https://github.com/" data-ga-click="(Logged out) Header, go to homepage, icon:logo-wordmark">
      <span class="mega-octicon octicon-logo-github"></span>
    </a>

    <div class="header-actions" role="navigation">
        <a class="btn btn-primary" href="/join" data-ga-click="(Logged out) Header, clicked Sign up, text:sign-up">Sign up</a>
      <a class="btn" href="/login?return_to=%2Fskranz%2FStratTourn%2Fblob%2Fmaster%2FREADME.md" data-ga-click="(Logged out) Header, clicked Sign in, text:sign-in">Sign in</a>
    </div>

    <div class="site-search repo-scope js-site-search" role="search">
      <form accept-charset="UTF-8" action="/skranz/StratTourn/search" class="js-site-search-form" data-global-search-url="/search" data-repo-search-url="/skranz/StratTourn/search" method="get"><div style="margin:0;padding:0;display:inline"><input name="utf8" type="hidden" value="&#x2713;" /></div>
  <input type="text"
    class="js-site-search-field is-clearable"
    data-hotkey="s"
    name="q"
    placeholder="Search"
    data-global-scope-placeholder="Search GitHub"
    data-repo-scope-placeholder="Search"
    tabindex="1"
    autocapitalize="off">
  <div class="scope-badge">This repository</div>
</form>
    </div>

      <ul class="header-nav left" role="navigation">
          <li class="header-nav-item">
            <a class="header-nav-link" href="/explore" data-ga-click="(Logged out) Header, go to explore, text:explore">Explore</a>
          </li>
          <li class="header-nav-item">
            <a class="header-nav-link" href="/features" data-ga-click="(Logged out) Header, go to features, text:features">Features</a>
          </li>
          <li class="header-nav-item">
            <a class="header-nav-link" href="https://enterprise.github.com/" data-ga-click="(Logged out) Header, go to enterprise, text:enterprise">Enterprise</a>
          </li>
          <li class="header-nav-item">
            <a class="header-nav-link" href="/blog" data-ga-click="(Logged out) Header, go to blog, text:blog">Blog</a>
          </li>
      </ul>

  </div>
</div>



      <div id="start-of-content" class="accessibility-aid"></div>
          <div class="site" itemscope itemtype="http://schema.org/WebPage">
    <div id="js-flash-container">
      
    </div>
    <div class="pagehead repohead instapaper_ignore readability-menu">
      <div class="container">
        
<ul class="pagehead-actions">

  <li>
      <a href="/login?return_to=%2Fskranz%2FStratTourn"
    class="btn btn-sm btn-with-count tooltipped tooltipped-n"
    aria-label="You must be signed in to watch a repository" rel="nofollow">
    <span class="octicon octicon-eye"></span>
    Watch
  </a>
  <a class="social-count" href="/skranz/StratTourn/watchers">
    2
  </a>

  </li>

  <li>
      <a href="/login?return_to=%2Fskranz%2FStratTourn"
    class="btn btn-sm btn-with-count tooltipped tooltipped-n"
    aria-label="You must be signed in to star a repository" rel="nofollow">
    <span class="octicon octicon-star"></span>
    Star
  </a>

    <a class="social-count js-social-count" href="/skranz/StratTourn/stargazers">
      1
    </a>

  </li>

    <li>
      <a href="/login?return_to=%2Fskranz%2FStratTourn"
        class="btn btn-sm btn-with-count tooltipped tooltipped-n"
        aria-label="You must be signed in to fork a repository" rel="nofollow">
        <span class="octicon octicon-repo-forked"></span>
        Fork
      </a>
      <a href="/skranz/StratTourn/network" class="social-count">
        1
      </a>
    </li>
</ul>

        <h1 itemscope itemtype="http://data-vocabulary.org/Breadcrumb" class="entry-title public">
          <span class="mega-octicon octicon-repo"></span>
          <span class="author"><a href="/skranz" class="url fn" itemprop="url" rel="author"><span itemprop="title">skranz</span></a></span><!--
       --><span class="path-divider">/</span><!--
       --><strong><a href="/skranz/StratTourn" class="js-current-repository" data-pjax="#js-repo-pjax-container">StratTourn</a></strong>

          <span class="page-context-loader">
            <img alt="" height="16" src="https://assets-cdn.github.com/assets/spinners/octocat-spinner-32-e513294efa576953719e4e2de888dd9cf929b7d62ed8d05f25e731d02452ab6c.gif" width="16" />
          </span>

        </h1>
      </div><!-- /.container -->
    </div><!-- /.repohead -->

    <div class="container">
      <div class="repository-with-sidebar repo-container new-discussion-timeline  ">
        <div class="repository-sidebar clearfix">
            
<nav class="sunken-menu repo-nav js-repo-nav js-sidenav-container-pjax js-octicon-loaders"
     role="navigation"
     data-pjax="#js-repo-pjax-container"
     data-issue-count-url="/skranz/StratTourn/issues/counts">
  <ul class="sunken-menu-group">
    <li class="tooltipped tooltipped-w" aria-label="Code">
      <a href="/skranz/StratTourn" aria-label="Code" class="selected js-selected-navigation-item sunken-menu-item" data-hotkey="g c" data-selected-links="repo_source repo_downloads repo_commits repo_releases repo_tags repo_branches /skranz/StratTourn">
        <span class="octicon octicon-code"></span> <span class="full-word">Code</span>
        <img alt="" class="mini-loader" height="16" src="https://assets-cdn.github.com/assets/spinners/octocat-spinner-32-e513294efa576953719e4e2de888dd9cf929b7d62ed8d05f25e731d02452ab6c.gif" width="16" />
</a>    </li>

      <li class="tooltipped tooltipped-w" aria-label="Issues">
        <a href="/skranz/StratTourn/issues" aria-label="Issues" class="js-selected-navigation-item sunken-menu-item" data-hotkey="g i" data-selected-links="repo_issues repo_labels repo_milestones /skranz/StratTourn/issues">
          <span class="octicon octicon-issue-opened"></span> <span class="full-word">Issues</span>
          <span class="js-issue-replace-counter"></span>
          <img alt="" class="mini-loader" height="16" src="https://assets-cdn.github.com/assets/spinners/octocat-spinner-32-e513294efa576953719e4e2de888dd9cf929b7d62ed8d05f25e731d02452ab6c.gif" width="16" />
</a>      </li>

    <li class="tooltipped tooltipped-w" aria-label="Pull requests">
      <a href="/skranz/StratTourn/pulls" aria-label="Pull requests" class="js-selected-navigation-item sunken-menu-item" data-hotkey="g p" data-selected-links="repo_pulls /skranz/StratTourn/pulls">
          <span class="octicon octicon-git-pull-request"></span> <span class="full-word">Pull requests</span>
          <span class="js-pull-replace-counter"></span>
          <img alt="" class="mini-loader" height="16" src="https://assets-cdn.github.com/assets/spinners/octocat-spinner-32-e513294efa576953719e4e2de888dd9cf929b7d62ed8d05f25e731d02452ab6c.gif" width="16" />
</a>    </li>


  </ul>
  <div class="sunken-menu-separator"></div>
  <ul class="sunken-menu-group">

    <li class="tooltipped tooltipped-w" aria-label="Pulse">
      <a href="/skranz/StratTourn/pulse" aria-label="Pulse" class="js-selected-navigation-item sunken-menu-item" data-selected-links="pulse /skranz/StratTourn/pulse">
        <span class="octicon octicon-pulse"></span> <span class="full-word">Pulse</span>
        <img alt="" class="mini-loader" height="16" src="https://assets-cdn.github.com/assets/spinners/octocat-spinner-32-e513294efa576953719e4e2de888dd9cf929b7d62ed8d05f25e731d02452ab6c.gif" width="16" />
</a>    </li>

    <li class="tooltipped tooltipped-w" aria-label="Graphs">
      <a href="/skranz/StratTourn/graphs" aria-label="Graphs" class="js-selected-navigation-item sunken-menu-item" data-selected-links="repo_graphs repo_contributors /skranz/StratTourn/graphs">
        <span class="octicon octicon-graph"></span> <span class="full-word">Graphs</span>
        <img alt="" class="mini-loader" height="16" src="https://assets-cdn.github.com/assets/spinners/octocat-spinner-32-e513294efa576953719e4e2de888dd9cf929b7d62ed8d05f25e731d02452ab6c.gif" width="16" />
</a>    </li>
  </ul>


</nav>

              <div class="only-with-full-nav">
                  
<div class="clone-url open"
  data-protocol-type="http"
  data-url="/users/set_protocol?protocol_selector=http&amp;protocol_type=clone">
  <h3><span class="text-emphasized">HTTPS</span> clone URL</h3>
  <div class="input-group js-zeroclipboard-container">
    <input type="text" class="input-mini input-monospace js-url-field js-zeroclipboard-target"
           value="https://github.com/skranz/StratTourn.git" readonly="readonly">
    <span class="input-group-button">
      <button aria-label="Copy to clipboard" class="js-zeroclipboard btn btn-sm zeroclipboard-button" data-copied-hint="Copied!" type="button"><span class="octicon octicon-clippy"></span></button>
    </span>
  </div>
</div>

  
<div class="clone-url "
  data-protocol-type="subversion"
  data-url="/users/set_protocol?protocol_selector=subversion&amp;protocol_type=clone">
  <h3><span class="text-emphasized">Subversion</span> checkout URL</h3>
  <div class="input-group js-zeroclipboard-container">
    <input type="text" class="input-mini input-monospace js-url-field js-zeroclipboard-target"
           value="https://github.com/skranz/StratTourn" readonly="readonly">
    <span class="input-group-button">
      <button aria-label="Copy to clipboard" class="js-zeroclipboard btn btn-sm zeroclipboard-button" data-copied-hint="Copied!" type="button"><span class="octicon octicon-clippy"></span></button>
    </span>
  </div>
</div>



<p class="clone-options">You can clone with
  <a href="#" class="js-clone-selector" data-protocol="http">HTTPS</a> or <a href="#" class="js-clone-selector" data-protocol="subversion">Subversion</a>.
  <a href="https://help.github.com/articles/which-remote-url-should-i-use" class="help tooltipped tooltipped-n" aria-label="Get help on which URL is right for you.">
    <span class="octicon octicon-question"></span>
  </a>
</p>



                <a href="/skranz/StratTourn/archive/master.zip"
                   class="btn btn-sm sidebar-button"
                   aria-label="Download the contents of skranz/StratTourn as a zip file"
                   title="Download the contents of skranz/StratTourn as a zip file"
                   rel="nofollow">
                  <span class="octicon octicon-cloud-download"></span>
                  Download ZIP
                </a>
              </div>
        </div><!-- /.repository-sidebar -->

        <div id="js-repo-pjax-container" class="repository-content context-loader-container" data-pjax-container>
          

<a href="/skranz/StratTourn/blob/573b7a5939f39e64dfdb46adc4bc1d0f4a88a220/README.md" class="hidden js-permalink-shortcut" data-hotkey="y">Permalink</a>

<!-- blob contrib key: blob_contributors:v21:f9b8fffee51192d4b3f45a279a3d83fb -->

<div class="file-navigation js-zeroclipboard-container">
  
<div class="select-menu js-menu-container js-select-menu left">
  <span class="btn btn-sm select-menu-button js-menu-target css-truncate" data-hotkey="w"
    data-master-branch="master"
    data-ref="master"
    title="master"
    role="button" aria-label="Switch branches or tags" tabindex="0" aria-haspopup="true">
    <span class="octicon octicon-git-branch"></span>
    <i>branch:</i>
    <span class="js-select-button css-truncate-target">master</span>
  </span>

  <div class="select-menu-modal-holder js-menu-content js-navigation-container" data-pjax aria-hidden="true">

    <div class="select-menu-modal">
      <div class="select-menu-header">
        <span class="select-menu-title">Switch branches/tags</span>
        <span class="octicon octicon-x js-menu-close" role="button" aria-label="Close"></span>
      </div>

      <div class="select-menu-filters">
        <div class="select-menu-text-filter">
          <input type="text" aria-label="Filter branches/tags" id="context-commitish-filter-field" class="js-filterable-field js-navigation-enable" placeholder="Filter branches/tags">
        </div>
        <div class="select-menu-tabs">
          <ul>
            <li class="select-menu-tab">
              <a href="#" data-tab-filter="branches" data-filter-placeholder="Filter branches/tags" class="js-select-menu-tab">Branches</a>
            </li>
            <li class="select-menu-tab">
              <a href="#" data-tab-filter="tags" data-filter-placeholder="Find a tag…" class="js-select-menu-tab">Tags</a>
            </li>
          </ul>
        </div>
      </div>

      <div class="select-menu-list select-menu-tab-bucket js-select-menu-tab-bucket" data-tab-filter="branches">

        <div data-filterable-for="context-commitish-filter-field" data-filterable-type="substring">


            <a class="select-menu-item js-navigation-item js-navigation-open selected"
               href="/skranz/StratTourn/blob/master/README.md"
               data-name="master"
               data-skip-pjax="true"
               rel="nofollow">
              <span class="select-menu-item-icon octicon octicon-check"></span>
              <span class="select-menu-item-text css-truncate-target" title="master">
                master
              </span>
            </a>
        </div>

          <div class="select-menu-no-results">Nothing to show</div>
      </div>

      <div class="select-menu-list select-menu-tab-bucket js-select-menu-tab-bucket" data-tab-filter="tags">
        <div data-filterable-for="context-commitish-filter-field" data-filterable-type="substring">


        </div>

        <div class="select-menu-no-results">Nothing to show</div>
      </div>

    </div>
  </div>
</div>

  <div class="btn-group right">
    <a href="/skranz/StratTourn/find/master"
          class="js-show-file-finder btn btn-sm empty-icon tooltipped tooltipped-s"
          data-pjax
          data-hotkey="t"
          aria-label="Quickly jump between files">
      <span class="octicon octicon-list-unordered"></span>
    </a>
    <button aria-label="Copy file path to clipboard" class="js-zeroclipboard btn btn-sm zeroclipboard-button" data-copied-hint="Copied!" type="button"><span class="octicon octicon-clippy"></span></button>
  </div>

  <div class="breadcrumb js-zeroclipboard-target">
    <span class='repo-root js-repo-root'><span itemscope="" itemtype="http://data-vocabulary.org/Breadcrumb"><a href="/skranz/StratTourn" class="" data-branch="master" data-direction="back" data-pjax="true" itemscope="url"><span itemprop="title">StratTourn</span></a></span></span><span class="separator">/</span><strong class="final-path">README.md</strong>
  </div>
</div>

<include-fragment class="commit commit-loader file-history-tease" src="/skranz/StratTourn/contributors/master/README.md">
  <div class="file-history-tease-header">
    Fetching contributors&hellip;
  </div>

  <div class="participation">
    <p class="loader-loading"><img alt="" height="16" src="https://assets-cdn.github.com/assets/spinners/octocat-spinner-32-EAF2F5-0bdc57d34b85c4a4de9d0d1db10cd70e8a95f33ff4f46c5a8c48b4bf4e5a9abe.gif" width="16" /></p>
    <p class="loader-error">Cannot retrieve contributors at this time</p>
  </div>
</include-fragment>
<div class="file">
  <div class="file-header">
    <div class="file-actions">

      <div class="btn-group">
        <a href="/skranz/StratTourn/raw/master/README.md" class="btn btn-sm " id="raw-url">Raw</a>
          <a href="/skranz/StratTourn/blame/master/README.md" class="btn btn-sm js-update-url-with-hash">Blame</a>
        <a href="/skranz/StratTourn/commits/master/README.md" class="btn btn-sm " rel="nofollow">History</a>
      </div>


          <button type="button" class="octicon-btn disabled tooltipped tooltipped-n" aria-label="You must be signed in to make or propose changes">
            <span class="octicon octicon-pencil"></span>
          </button>

        <button type="button" class="octicon-btn octicon-btn-danger disabled tooltipped tooltipped-n" aria-label="You must be signed in to make or propose changes">
          <span class="octicon octicon-trashcan"></span>
        </button>
    </div>

    <div class="file-info">
        849 lines (653 sloc)
        <span class="file-info-divider"></span>
      43.065 kb
    </div>
  </div>
    <div id="readme" class="blob instapaper_body">
    <article class="markdown-body entry-content" itemprop="mainContentOfPage"><table data-table-type="yaml-metadata">
  <thead>
  <tr>
  <th>output</th>
  </tr>
  </thead>
  <tbody>
  <tr>
  <td><div><table>
  <thead>
  <tr>
  <th>html_document</th>
  </tr>
  </thead>
  <tbody>
  <tr>
  <td><div><table>
  <thead>
  <tr>
  <th>highlight</th>

  <th>theme</th>

  <th>toc</th>
  </tr>
  </thead>
  <tbody>
  <tr>
  <td><div>textmate</div></td>

  <td><div>readable</div></td>

  <td><div>true</div></td>
  </tr>
  </tbody>
</table></div></td>
  </tr>
  </tbody>
</table></div></td>
  </tr>
  </tbody>
</table><h1>
<a id="user-content-analyzing-cooperation-with-game-theory-and-simulation" class="anchor" href="#analyzing-cooperation-with-game-theory-and-simulation" aria-hidden="true"><span class="octicon octicon-link"></span></a>Analyzing Cooperation with Game Theory and Simulation</h1>

<h1>
<a id="user-content-tutorial-for-the-r-package-strattourn" class="anchor" href="#tutorial-for-the-r-package-strattourn" aria-hidden="true"><span class="octicon octicon-link"></span></a>Tutorial for the R package StratTourn</h1>

<div class="highlight highlight-r"><pre><span class="pl-e">knitr</span><span class="pl-k">::</span><span class="pl-smi">opts_chunk</span><span class="pl-k">$</span>set(<span class="pl-v">error</span> <span class="pl-k">=</span> <span class="pl-c1">TRUE</span>)</pre></div>

<p><strong>Date: 2014-10-28</strong></p>

<p><strong>Author: Sebastian Kranz (<a href="mailto:sebastian.kranz@uni-ulm.de">sebastian.kranz@uni-ulm.de</a>)</strong></p>

<p><strong>with help by Martin Kies (<a href="mailto:martin.kies@uni-ulm.de">martin.kies@uni-ulm.de</a>)</strong></p>

<h2>
<a id="user-content-1-installing-neccessary-software" class="anchor" href="#1-installing-neccessary-software" aria-hidden="true"><span class="octicon octicon-link"></span></a>1. Installing neccessary software</h2>

<h3>
<a id="user-content-11-installing-r-and-rstudio" class="anchor" href="#11-installing-r-and-rstudio" aria-hidden="true"><span class="octicon octicon-link"></span></a>1.1 Installing R and RStudio</h3>

<p>First you need to install R, which is a very popular and powerful open source statistical programming language. You can download R for Windows, Max or Linux here:</p>

<p><a href="http://cran.r-project.org/">http://cran.r-project.org/</a></p>

<p>Note: If you have already installed R, you may want to update to the newest version by installing it again. </p>

<p>I recommend to additionally install RStudio, which is a great open source IDE for R:</p>

<p><a href="http://rstudio.org/">http://rstudio.org/</a></p>

<h3>
<a id="user-content-12-installing-necessary-r-packages" class="anchor" href="#12-installing-necessary-r-packages" aria-hidden="true"><span class="octicon octicon-link"></span></a>1.2 Installing necessary R packages</h3>

<p>You need to install several R packages from the internet. To do so, simply run in the R console the following code (you can use copy &amp; paste):</p>

<div class="highlight highlight-r"><pre>install.packages(<span class="pl-s"><span class="pl-pds">"</span>devtools<span class="pl-pds">"</span></span>)
install.packages(<span class="pl-s"><span class="pl-pds">"</span>data.table<span class="pl-pds">"</span></span>)
install.packages(<span class="pl-s"><span class="pl-pds">"</span>ggplot2<span class="pl-pds">"</span></span>)
install.packages(<span class="pl-s"><span class="pl-pds">"</span>reshape2<span class="pl-pds">"</span></span>)
install.packages(<span class="pl-s"><span class="pl-pds">"</span>dplyr<span class="pl-pds">"</span></span>)
install.packages(<span class="pl-s"><span class="pl-pds">"</span>shiny<span class="pl-pds">"</span></span>)
install.packages(<span class="pl-s"><span class="pl-pds">"</span>knitr<span class="pl-pds">"</span></span>)
install.packages(<span class="pl-s"><span class="pl-pds">"</span>xtable<span class="pl-pds">"</span></span>)
install.packages(<span class="pl-s"><span class="pl-pds">"</span>shinyBS<span class="pl-pds">"</span></span>)
install.packages(<span class="pl-s"><span class="pl-pds">"</span>googleVis<span class="pl-pds">"</span></span>)


library(<span class="pl-smi">devtools</span>)
install_github(<span class="pl-v">repo</span><span class="pl-k">=</span><span class="pl-s"><span class="pl-pds">"</span>skranz/restorepoint<span class="pl-pds">"</span></span>)
install_github(<span class="pl-v">repo</span><span class="pl-k">=</span><span class="pl-s"><span class="pl-pds">"</span>skranz/sktools<span class="pl-pds">"</span></span>)
install_github(<span class="pl-v">repo</span><span class="pl-k">=</span><span class="pl-s"><span class="pl-pds">"</span>skranz/stringtools<span class="pl-pds">"</span></span>)
install_github(<span class="pl-v">repo</span><span class="pl-k">=</span><span class="pl-s"><span class="pl-pds">"</span>skranz/dplyrExtras<span class="pl-pds">"</span></span>)
install_github(<span class="pl-v">repo</span><span class="pl-k">=</span><span class="pl-s"><span class="pl-pds">"</span>skranz/StratTourn<span class="pl-pds">"</span></span>)
install_github(<span class="pl-v">repo</span><span class="pl-k">=</span><span class="pl-s"><span class="pl-pds">"</span>skranz/shinyAce<span class="pl-pds">"</span></span>)
</pre></div>

<h2>
<a id="user-content-2-brief-background-the-prisoners-dilemma-game" class="anchor" href="#2-brief-background-the-prisoners-dilemma-game" aria-hidden="true"><span class="octicon octicon-link"></span></a>2. Brief Background: The Prisoners' Dilemma Game</h2>

<p>In the 'Evolution of Cooperation' Robert Axelrod describes his famous computer tournament that he used to investigate effective cooperation strategies in repeated social dilemma situations. His tournament was based on a repeated <em>prisoner's dilemma game</em>, which I will also use as an example in this tutorial.</p>

<h3>
<a id="user-content-21-the-one-shot-prisoners-dilemma" class="anchor" href="#21-the-one-shot-prisoners-dilemma" aria-hidden="true"><span class="octicon octicon-link"></span></a>2.1 The one-shot Prisoner's Dilemma</h3>

<p>A one-shot prisoner's dilemma (short: PD) is played only once. We can describe a PD by the following <em>payoff matrix</em>:</p>

<p></p><table border="1">
<tr>
    <td align="center">Pl 1. / Pl. 2</td>
    <th align="center">C</th>
    <th align="center">D</th>
  </tr>
<tr>
    <th align="center">C</th>
    <td align="center">  1, 1</td>
    <td align="center"> -1, 2</td>
  </tr>
<tr>
    <th align="center">D</th>
    <td align="center">  2,-1</td>
    <td align="center">  0, 0</td>
</tr>
</table>

<p>Each player can either cooperate <em>C</em> or defect <em>D</em>, which means not to cooperate. The row shows player 1's action and the column player 2's. The cells show the <em>payoffs</em> of player 1 and 2 for each <em>action profile</em>. For example, when player 1 cooperates C and player 2 defects D, i.e. the action profile (C,D) is played, then player 1's payoff is -1 and player 2's payoff is 2.</p>

<p>The highest average payoff (1,1) could be achieved if both players cooperate (C,C). Yet, assume that both players decide independently which action they choose, i.e. player 1's action does not influence player 2's action and vice versa. Then no matter which action the other player chooses, a player always maximizes its own payoff by choosing D. In game theoretic terms, choosing D is <em>strictly dominant</em> in a PD game that is played only once. (Consequently, the only <em>Nash equilibrium</em> of the one-shot PD is (D,D)). </p>

<h3>
<a id="user-content-22-the-repeated-prisoners-dilemma" class="anchor" href="#22-the-repeated-prisoners-dilemma" aria-hidden="true"><span class="octicon octicon-link"></span></a>2.2 The repeated Prisoner's Dilemma</h3>

<p>In this seminar, we will mostly consider games that are repeated for an uncertain number of periods. Let $\delta \in [0,1)$ be a continuation probability (we will also often refer to $\delta$ as <em>discount factor</em>). After each period a random number is drawn and the repeated game ends with probability $1-\delta$, i.e. it continues with probability $\delta$. In the basic version (formally called a PD game with <em>perfect monitoring</em>) all players exactly observe the actions that the other players have played in the previous periods. It is then no longer strictly dominant to always play D. For example, player 2's action in period 2 may depend on what player 1 did in period 1: she may only play C if player 1 has played C in period 1 and otherwise play D. A player's optimal strategy now depends on how the other player reacts to her action and cooperation may become rational even for pure egoists.</p>

<p>It turns out that if the continuation probability $\delta$ is large enough, such repeated games often have a very large number of <em>Nash equilibria</em>. This means we can have many possible profiles of strategies that are stable in the sense that it is optimal for each player to follow her strategy given the strategies of the other players. In some Nash equilibria players will cooperate a lot, in others very little or not at all.</p>

<h3>
<a id="user-content-23-what-will-we-do-in-the-seminar" class="anchor" href="#23-what-will-we-do-in-the-seminar" aria-hidden="true"><span class="octicon octicon-link"></span></a>2.3 What will we do in the seminar?</h3>

<p>We search for "succesful" cooperative strategy profiles in several strategic interactions and study which factors make cooperation harder and how one best adapts cooperation strategies to such factors.</p>

<p>We do this search by programming strategies in R and let them play against each other in a tournament (more on that below) and then rank strategies against each other.</p>

<p>In different tasks we will use different criteria to rank the strategies into more or less succesful strategies. While we discuss different criteria in detail later, a core idea is that your strategy should achieve high payoffs when playing against itself and against other submitted strategies.</p>

<h2>
<a id="user-content-3-getting-started-developing-strategies-for-the-repeated-prisoners-dilemma-in-r" class="anchor" href="#3-getting-started-developing-strategies-for-the-repeated-prisoners-dilemma-in-r" aria-hidden="true"><span class="octicon octicon-link"></span></a>3. Getting Started: Developing strategies for the repeated Prisoner's Dilemma in R</h2>

<p>Preparations:</p>

<ol class="task-list">
<li>Make sure you installed all software and packages as described in Section 1</li>
<li>Download the file <em>pdgame.r</em>, save it in some working directory, and open it with RStudio. </li>
<li>Press the "Source" button above on the right of the editor window to load all functions of this file.</li>
<li>Consider the code inside the function examples.pd, select the following lines and press the "Run" button (or press Ctrl-Enter):</li>
</ol>

<div class="highlight highlight-r"><pre>  <span class="pl-c"># Load package</span>
  library(<span class="pl-smi">StratTourn</span>)</pre></div>

<div class="highlight highlight-r"><pre>  <span class="pl-c"># Load package</span>
  library(<span class="pl-smi">StratTourn</span>)

  <span class="pl-c"># Generate a PD game object</span>
  <span class="pl-v">game</span> <span class="pl-k">=</span> make.pd.game(<span class="pl-v">err.D.prob</span><span class="pl-k">=</span><span class="pl-c1">0.15</span>)
  <span class="pl-c"># Pick a pair of strategies (strategies are defined below)</span>
  <span class="pl-v">strat</span> <span class="pl-k">=</span> nlist(<span class="pl-smi">tit.for.tat</span>,<span class="pl-smi">random.action</span>)

  <span class="pl-c"># Let the strategies play against each other one repeated PD</span>
  run.rep.game(<span class="pl-v">delta</span><span class="pl-k">=</span><span class="pl-c1">0.9</span>, <span class="pl-v">game</span><span class="pl-k">=</span><span class="pl-smi">game</span>, <span class="pl-v">strat</span> <span class="pl-k">=</span> <span class="pl-smi">strat</span>)
</pre></div>

<p>This code simulates a repated PD with continuation probability $\delta=0.9$ in which player 1 follows a strategy called "tit.for.tat" and player 2 follows a strategy called "random.action". The resulting output will look similar to the following:</p>

<pre><code>  $rs
        match.id         strat t i  u a obs.i obs.j err.D.i err.D.j strat.state
   1: 1121912743   tit.for.tat 1 1 -1 C     C     C   FALSE   FALSE            
   2: 1121912743 random.action 1 2  2 D     C     C   FALSE   FALSE            
   3: 1121912743   tit.for.tat 2 1  2 D     C     D   FALSE   FALSE            
   4: 1121912743 random.action 2 2 -1 C     D     C   FALSE   FALSE            
   5: 1121912743   tit.for.tat 3 1 -1 C     D     C   FALSE   FALSE            
   6: 1121912743 random.action 3 2  2 D     C     D   FALSE   FALSE 
   ...
</code></pre>

<p>The table shows the results of one repeated prisoners dilemma game. The column <code>t</code> is the period, the column <code>i</code> the player and <code>strat</code> her strategy. The column <code>a</code> is the action player i has chosen in period t and <code>u</code> is her resulting payoff.</p>

<p>For example, in period t=1, player 1 (tit.for.tat) has cooperated (C) and player 2 (random.action) has defected (D). Consequently, player 1 got a payoff of u = -1 and player 2 got a payoff of 2.</p>

<p>The columns <code>obs.i</code> and <code>obs.j</code> show the observations at the beginning of a period, here just the previous actions of player i hersefl (obs.i) and the other player (obs.j). </p>

<p>Note: we will consider a more interesting variant of the prisoners' dilemma game with the possibility of observation errors. An error can make it look as if a player has defected (D) in the previous round, even when he has cooperated (C). The columns err.D.i and err.D.j indicate whether there was an observation error in obs.i or obs.j.</p>

<p>You see that in t=2, player i=1 correctly observes that the other player (j=2) has played (D) in period (D). As explained below, this causes the tit-for-tat strategy also to play (D) in period 2. </p>

<p>These tables will be very helpful to understand what your programmed strategy does and to check whether it indeed works as you have planned.</p>

<p>Below the big table you see a small table that shows the average payoffs of each player across all periods.</p>

<h3>
<a id="user-content-31-tit-for-tat" class="anchor" href="#31-tit-for-tat" aria-hidden="true"><span class="octicon octicon-link"></span></a>3.1 Tit-for-Tat</h3>

<p>Tit-for-Tat was the winning strategy in Axelrod's original tournament. It has a simple structure:</p>

<ul class="task-list">
<li>Start nice by cooperating (C) in period 1</li>
<li>In later periods play that action that the other player has played in the previous period. </li>
</ul>

<h3>
<a id="user-content-32-tit-for-tat-as-an-r-function" class="anchor" href="#32-tit-for-tat-as-an-r-function" aria-hidden="true"><span class="octicon octicon-link"></span></a>3.2 Tit-for-Tat as an R function</h3>

<p>Further below in the file pdgame.r you find a definition of tit.for.tat as a R function:</p>

<div class="highlight highlight-r"><pre><span class="pl-v">tit.for.tat</span> <span class="pl-k">=</span> <span class="pl-k">function</span>(<span class="pl-smi">obs</span>,<span class="pl-smi">i</span>,<span class="pl-smi">t</span>,<span class="pl-k">...</span>) {
  debug.store(<span class="pl-s"><span class="pl-pds">"</span>tit.for.tat<span class="pl-pds">"</span></span>,<span class="pl-smi">i</span>,<span class="pl-smi">t</span>)       <span class="pl-c"># Store each call for each player</span>
  debug.restore(<span class="pl-s"><span class="pl-pds">"</span>tit.for.tat<span class="pl-pds">"</span></span>,<span class="pl-v">i</span><span class="pl-k">=</span><span class="pl-c1">1</span>,<span class="pl-v">t</span><span class="pl-k">=</span><span class="pl-c1">2</span>) <span class="pl-c"># Restore call for player i in period t</span>

  <span class="pl-c"># Cooperate in the first period</span>
  <span class="pl-k">if</span> (<span class="pl-smi">t</span><span class="pl-k">==</span><span class="pl-c1">1</span>)
    <span class="pl-k">return</span>(<span class="pl-k">list</span>(<span class="pl-v">a</span><span class="pl-k">=</span><span class="pl-s"><span class="pl-pds">"</span>C<span class="pl-pds">"</span></span>))

  <span class="pl-c"># In later periods, return the other player's previous action</span>
  <span class="pl-v">j</span> <span class="pl-k">=</span> <span class="pl-c1">3</span><span class="pl-k">-</span><span class="pl-smi">i</span>
  <span class="pl-v">a</span> <span class="pl-k">=</span> <span class="pl-smi">obs</span><span class="pl-k">$</span><span class="pl-smi">a</span>[<span class="pl-smi">j</span>]
  <span class="pl-k">return</span>(<span class="pl-k">list</span>(<span class="pl-v">a</span><span class="pl-k">=</span><span class="pl-smi">a</span>))
}
</pre></div>

<p>The first line</p>

<div class="highlight highlight-r"><pre><span class="pl-v">tit.for.tat</span> <span class="pl-k">=</span> <span class="pl-k">function</span>(<span class="pl-smi">obs</span>,<span class="pl-smi">i</span>,<span class="pl-smi">t</span>,<span class="pl-k">...</span>) {</pre></div>

<p>says that tit.for.tat is a function with the following arguments:</p>

<ul class="task-list">
<li>obs: this is a <a href="http://cran.r-project.org/doc/manuals/R-intro.html#Lists">list</a> that contains a player's observations about behavior from the previous period. The exact structure of observations will depend on the specification of the game that is played. In our basic PD game obs contains an element obs$a that is a vector with the two actions that the players have chosen in the previous period.</li>
<li>i: this is simply the number of the player, either 1 or 2</li>
<li>t: this is the number of the current period</li>
<li>...: these are some arguments, we don't use for now. Please, always add the ... when defining your strategies. Otherwise, the code may not run correctly. </li>
</ul>

<p>Every strategy must have these 4 arguments. There may be additional aguments if a strategy uses states to pass additional information between periods. This is explained further below.</p>

<p>The function run.rep.game now calls this function tit.for.tat in every period and provides the corresponding values of i,t,obs. E.g. if it is called in the third period for player 1 and in the previous round (D,C) was played, we have </p>

<pre><code>    i==1, t==3, obs$a[1]=="D" and obs$a[2]=="C".
</code></pre>

<p>Based on the values of obs, t, i the function must return the action that the player chooses.</p>

<p>The lines </p>

<div class="highlight highlight-r"><pre>  debug.store(<span class="pl-s"><span class="pl-pds">"</span>tit.for.tat<span class="pl-pds">"</span></span>,<span class="pl-smi">i</span>,<span class="pl-smi">t</span>) <span class="pl-c"># Store each call for each player</span>
  debug.restore(<span class="pl-s"><span class="pl-pds">"</span>tit.for.tat<span class="pl-pds">"</span></span>,<span class="pl-v">i</span><span class="pl-k">=</span><span class="pl-c1">1</span>,<span class="pl-v">t</span><span class="pl-k">=</span><span class="pl-c1">2</span>) <span class="pl-c"># Restore call for player i in period t</span></pre></div>

<p>are useful for debugging a strategy and can be ignored for the moment (you can also remove them without changing the behavior of the strategy).</p>

<p>The lines</p>

<div class="highlight highlight-r"><pre>  <span class="pl-k">if</span> (<span class="pl-smi">t</span><span class="pl-k">==</span><span class="pl-c1">1</span>)
    <span class="pl-k">return</span>(<span class="pl-k">list</span>(<span class="pl-v">a</span><span class="pl-k">=</span><span class="pl-s"><span class="pl-pds">"</span>C<span class="pl-pds">"</span></span>))</pre></div>

<p>state that in the first period, i.e. t==1, the player cooperates. That the player cooperates means that the function returns a list</p>

<div class="highlight highlight-r"><pre>  <span class="pl-k">list</span>(<span class="pl-v">a</span><span class="pl-k">=</span><span class="pl-s"><span class="pl-pds">"</span>C<span class="pl-pds">"</span></span>)</pre></div>

<p>where the element a is "C". In more complex games, a function may return more than a single action. The exact structure of the list of actions that a function has to return will be explained in the corresponding exercises.</p>

<p>Side remark: we ommitted the "{" brackets of the 'if' condition. We can do that whenever there follows exactly one statement after the condition.</p>

<p>The lines</p>

<div class="highlight highlight-r"><pre>  <span class="pl-v">j</span> <span class="pl-k">=</span> <span class="pl-c1">3</span><span class="pl-k">-</span><span class="pl-smi">i</span>
  <span class="pl-v">a</span> <span class="pl-k">=</span> <span class="pl-smi">obs</span><span class="pl-k">$</span><span class="pl-smi">a</span>[<span class="pl-smi">j</span>]
  <span class="pl-k">return</span>(<span class="pl-k">list</span>(<span class="pl-v">a</span><span class="pl-k">=</span><span class="pl-smi">a</span>))</pre></div>

<p>describe the behavior in periods t&gt;1. The variable j will be the index of the other player (if i=1 then j=2 and if i=2 then j=1). Lines 2-3 say that the player choses that action that the other player has played in the previous period, i.e. <code>obs$a[j]</code>.</p>

<h3>
<a id="user-content-33-strategies-that-use-states-example-strangedefector" class="anchor" href="#33-strategies-that-use-states-example-strangedefector" aria-hidden="true"><span class="octicon octicon-link"></span></a>3.3 Strategies that use states. Example: strange.defector</h3>

<p>Many strategies rely not only on the most recent observations which are saved in obs. Consider for example this self-developed (not very clever) strategy:</p>

<ul class="task-list">
<li>"Strange Defector":  In the first round cooperates with 70% probability, otherwise defects. As long as the player cooperates, he continues in this random fashion. Once the player defects, he plays 4 additional times "defect" in a row. Afterwards, he plays again as in the first period (randomizing, and after defection, 4 defects in a row).</li>
</ul>

<p>Here is an R implementation of this strategy:</p>

<div class="highlight highlight-r"><pre><span class="pl-en">strange.defector</span> <span class="pl-k">&lt;-</span> <span class="pl-k">function</span>(<span class="pl-smi">obs</span>, <span class="pl-smi">i</span>, <span class="pl-smi">t</span>, <span class="pl-v">still.defect</span><span class="pl-k">=</span><span class="pl-c1">0</span>, <span class="pl-k">...</span>){
  debug.store(<span class="pl-s"><span class="pl-pds">"</span>strange.defector<span class="pl-pds">"</span></span>,<span class="pl-smi">i</span>,<span class="pl-smi">t</span>) <span class="pl-c"># Store each call for each player</span>
  debug.restore(<span class="pl-s"><span class="pl-pds">"</span>strange.defector<span class="pl-pds">"</span></span>,<span class="pl-v">i</span><span class="pl-k">=</span><span class="pl-c1">1</span>,<span class="pl-v">t</span><span class="pl-k">=</span><span class="pl-c1">2</span>) <span class="pl-c"># Restore call for player i in period t</span>

  <span class="pl-c"># Randomize between C and D</span>
  <span class="pl-k">if</span> (<span class="pl-smi">still.defect</span><span class="pl-k">==</span><span class="pl-c1">0</span>) {
    <span class="pl-v">do.cooperate</span> <span class="pl-k">=</span> (runif(<span class="pl-c1">1</span>)<span class="pl-k">&lt;</span><span class="pl-c1">0.7</span>) 
    <span class="pl-c"># With 60% probability choose C</span>
    <span class="pl-k">if</span> (<span class="pl-smi">do.cooperate</span>){
      <span class="pl-k">return</span>(<span class="pl-k">list</span>(<span class="pl-v">a</span><span class="pl-k">=</span><span class="pl-s"><span class="pl-pds">"</span>C<span class="pl-pds">"</span></span>, <span class="pl-v">still.defect</span><span class="pl-k">=</span><span class="pl-c1">0</span>))
    } <span class="pl-k">else</span> {
      <span class="pl-k">return</span>(<span class="pl-k">list</span>(<span class="pl-v">a</span><span class="pl-k">=</span><span class="pl-s"><span class="pl-pds">"</span>D<span class="pl-pds">"</span></span>, <span class="pl-v">still.defect</span><span class="pl-k">=</span><span class="pl-c1">4</span>))
    }
  }

  <span class="pl-c"># still.defect is bigger 0: play D and reduce still.defect by 1</span>
  <span class="pl-v">still.defect</span> <span class="pl-k">=</span> <span class="pl-smi">still.defect</span> <span class="pl-k">-</span><span class="pl-c1">1</span>
  <span class="pl-k">return</span>(<span class="pl-k">list</span>(<span class="pl-v">a</span><span class="pl-k">=</span><span class="pl-s"><span class="pl-pds">"</span>D<span class="pl-pds">"</span></span>,<span class="pl-v">still.defect</span><span class="pl-k">=</span><span class="pl-smi">still.defect</span>))
}</pre></div>

<p>Compared to the tit.for.tat function, the strange.defector function has an additional argument, namely <code>still.defect</code> which in the first round t=1 has the value 0.
Also the returned lists contain an additional field named <code>still.defect</code>.  The variable still.defect is a  manually generated <em>state variable</em>.</p>

<h4>
<a id="user-content-how-state-variables-transfer-information-between-periods" class="anchor" href="#how-state-variables-transfer-information-between-periods" aria-hidden="true"><span class="octicon octicon-link"></span></a>How state variables transfer information between periods:</h4>

<pre><code>The value of a state variable that is passed to your function in period t is the value of the state that your function has returned in period t-1. (The value of a state in period 1 is the value you specify in the function definition).
</code></pre>

<h4>
<a id="user-content-name-and-number-of-state-variables" class="anchor" href="#name-and-number-of-state-variables" aria-hidden="true"><span class="octicon octicon-link"></span></a>Name and number of state variables</h4>

<pre><code>You can freely pick the name of a state variable (except for the reserved names ops,i,t and a) and you can have more than one state variable.
</code></pre>

<h4>
<a id="user-content-which-values-can-state-variables-take" class="anchor" href="#which-values-can-state-variables-take" aria-hidden="true"><span class="octicon octicon-link"></span></a>Which values can state variables take?</h4>

<pre><code>States can take all sort of values: numbers (e.g 4.5), logical values (TRUE or FALSE), strings (e.g. "angry"), or even vectors. You just should not store a list in a state variable.
</code></pre>

<h4>
<a id="user-content-back-to-the-example" class="anchor" href="#back-to-the-example" aria-hidden="true"><span class="octicon octicon-link"></span></a>Back to the example:</h4>

<p>In our example, the state variable <em>still.defect</em> captures the information how many rounds the streak of defection should still last.</p>

<p>Let us have a more detailed look at the code of the example. The line</p>

<div class="highlight highlight-r"><pre>  <span class="pl-en">strange.defector</span> <span class="pl-k">&lt;-</span> <span class="pl-k">function</span>(<span class="pl-smi">obs</span>, <span class="pl-smi">i</span>, <span class="pl-smi">t</span>, <span class="pl-v">still.defect</span><span class="pl-k">=</span><span class="pl-c1">0</span>,<span class="pl-k">...</span>){</pre></div>

<p>initializes the function with a state still.defect that has in the first period a value of 0. 
The lines</p>

<div class="highlight highlight-r"><pre>  <span class="pl-k">if</span> (<span class="pl-smi">still.defect</span><span class="pl-k">==</span><span class="pl-c1">0</span>) {
    <span class="pl-v">do.cooperate</span> <span class="pl-k">=</span> runif(<span class="pl-c1">1</span>)<span class="pl-k">&lt;</span><span class="pl-c1">0.7</span> 
    <span class="pl-c"># With 60% probability choose C</span>
    <span class="pl-k">if</span> (<span class="pl-smi">do.cooperate</span>){
      <span class="pl-k">return</span>(<span class="pl-k">list</span>(<span class="pl-v">a</span><span class="pl-k">=</span><span class="pl-s"><span class="pl-pds">"</span>C<span class="pl-pds">"</span></span>, <span class="pl-v">still.defect</span><span class="pl-k">=</span><span class="pl-c1">0</span>))
    } <span class="pl-k">else</span> {
      <span class="pl-k">return</span>(<span class="pl-k">list</span>(<span class="pl-v">a</span><span class="pl-k">=</span><span class="pl-s"><span class="pl-pds">"</span>D<span class="pl-pds">"</span></span>, <span class="pl-v">still.defect</span><span class="pl-k">=</span><span class="pl-c1">4</span>))
    }
  }
</pre></div>

<p>first check whether we are in the initial state (still.defect==0), in which we randomize between C and D. If this is the case, we draw with the command</p>

<div class="highlight highlight-r"><pre>  <span class="pl-v">do.cooperate</span> <span class="pl-k">=</span> (runif(<span class="pl-c1">1</span>)<span class="pl-k">&lt;</span><span class="pl-c1">0.7</span>) </pre></div>

<p>a logical random variable that is TRUE with 70% probability and otherwise FALSE. (To see this, note that runif(1) draws one uniformely distributed random variable between 0 and 1). The lines</p>

<div class="highlight highlight-r"><pre>    <span class="pl-k">if</span> (<span class="pl-smi">do.cooperate</span>){
      <span class="pl-k">return</span>(<span class="pl-k">list</span>(<span class="pl-v">a</span><span class="pl-k">=</span><span class="pl-s"><span class="pl-pds">"</span>C<span class="pl-pds">"</span></span>, <span class="pl-v">still.defect</span><span class="pl-k">=</span><span class="pl-c1">0</span>))</pre></div>

<p>state that if the random variable says that we should cooperate, we return the action "C" and keep the state still.defect=0. The lines </p>

<div class="highlight highlight-r"><pre>    } <span class="pl-k">else</span> {
      <span class="pl-k">return</span>(<span class="pl-k">list</span>(<span class="pl-v">a</span><span class="pl-k">=</span><span class="pl-s"><span class="pl-pds">"</span>D<span class="pl-pds">"</span></span>, <span class="pl-v">still.defect</span><span class="pl-k">=</span><span class="pl-c1">4</span>))
    }</pre></div>

<p>say that otherwise, we return the action "D" and set the state still.defect = 4. This means that we will defect for the next 4 periods. In the next period the value of still.defect will be 4 and the code at the bottom of the function will be called:</p>

<div class="highlight highlight-r"><pre>  <span class="pl-v">still.defect</span> <span class="pl-k">=</span> <span class="pl-smi">still.defect</span> <span class="pl-k">-</span><span class="pl-c1">1</span>
  <span class="pl-k">return</span>(<span class="pl-k">list</span>(<span class="pl-v">a</span><span class="pl-k">=</span><span class="pl-s"><span class="pl-pds">"</span>D<span class="pl-pds">"</span></span>,<span class="pl-v">still.defect</span><span class="pl-k">=</span><span class="pl-smi">still.defect</span>))</pre></div>

<p>The first line reduces still.defect by 1. (Hence, after 4 periods, we will again be in the state still.defect =0 and choose a random action). The second line returns our action a="D" and the new value of our state still.defect.</p>

<p>If you run a single repeated game the result table also shows in each row, the values of the strategies' states at the <em>end</em> of the period:</p>

<div class="highlight highlight-r"><pre>  run.rep.game(<span class="pl-v">game</span><span class="pl-k">=</span><span class="pl-smi">game</span>, 
               <span class="pl-v">strat</span> <span class="pl-k">=</span> nlist(<span class="pl-smi">strange.defector</span>,<span class="pl-smi">tit.for.tat</span>))</pre></div>

<p>The output will look similar to</p>

<pre><code>$rs
      match.id            strat  t i  u a obs.i obs.j err.D.i err.D.j    strat.state
 1: 1492717910 strange.defector  1 1  2 D     C     C   FALSE   FALSE still.defect=4
 2: 1492717910      tit.for.tat  1 2 -1 C     C     C   FALSE   FALSE               
 3: 1492717910 strange.defector  2 1  0 D     D     C   FALSE   FALSE still.defect=3
 4: 1492717910      tit.for.tat  2 2  0 D     C     D   FALSE   FALSE               
 ...
</code></pre>

<h4>
<a id="user-content-important-always-return-a-list-with-all-strategy-states" class="anchor" href="#important-always-return-a-list-with-all-strategy-states" aria-hidden="true"><span class="octicon octicon-link"></span></a>Important: always return a list with all strategy states</h4>

<pre><code>Every return statement of your strategy must return a list that has values for all actions
and all strategy states. Even if you don't currently use some strategy state, you have to 
return a value.
</code></pre>

<h3>
<a id="user-content-34-exercise" class="anchor" href="#34-exercise" aria-hidden="true"><span class="octicon octicon-link"></span></a>3.4 Exercise:</h3>

<p>Implement the following strategy in R.</p>

<ul class="task-list">
<li>
<p>tit3tat: The player starts with C and plays like tit-for-tat in period t=2 and t=3. In period t&gt;3 the player plays with 60% probability like tit-for-tat and with 30% probability he plays the action that the other player played in the pre-previous period, i.e. in t-2 and with 10% probability he plays the action the other player played in t-3.</p>

<p>Hints:</p>
</li>
<li>To do something with 60% probability, you can draw a random variable x with the command x=runif(1) that is uniformely distributed between 0 and 1 and then check whether x&lt;=0.6. To do something else with 30 probability, you can check 0.6 &lt; x &amp; x &lt;= 0.9 and so on...</li>
<li>To save a longer history you can either use a function that has more than one state or store a vector in a state variable.</li>
</ul>

<h2>
<a id="user-content-4-running-a-tournament-between-strategies" class="anchor" href="#4-running-a-tournament-between-strategies" aria-hidden="true"><span class="octicon octicon-link"></span></a>4. Running a tournament between strategies</h2>

<p>The following lines run a tournament between 4 specified strategies</p>

<div class="highlight highlight-r"><pre>  set.storing(<span class="pl-c1">FALSE</span>)
  options(<span class="pl-v">width</span><span class="pl-k">=</span><span class="pl-c1">100</span>)</pre></div>

<div class="highlight highlight-r"><pre>  <span class="pl-c"># Init game</span>
  <span class="pl-v">game</span> <span class="pl-k">=</span> make.pd.game(<span class="pl-v">err.D.prob</span><span class="pl-k">=</span><span class="pl-c1">0.15</span>)

  getwd()
  <span class="pl-c"># Set working directory in which data is stored</span>

  <span class="pl-c"># Adapt directory. Note: use / instead of \ to seperate folders</span>
  setwd(<span class="pl-s"><span class="pl-pds">"</span>D:/libraries/StratTourn/studies<span class="pl-pds">"</span></span>) 

  <span class="pl-c"># Init and run a tournament of several strategies against each other  </span>
  <span class="pl-v">strat</span> <span class="pl-k">=</span> nlist(<span class="pl-smi">tit.for.tat</span>,<span class="pl-smi">always.defect</span>, <span class="pl-smi">always.coop</span>, <span class="pl-smi">random.action</span>)  
  <span class="pl-v">tourn</span> <span class="pl-k">=</span> init.tournament(<span class="pl-v">game</span><span class="pl-k">=</span><span class="pl-smi">game</span>, <span class="pl-v">strat</span><span class="pl-k">=</span><span class="pl-smi">strat</span>)

  <span class="pl-c">#set.storing(FALSE)  # uncomment to make code run faster</span>
  <span class="pl-v">tourn</span> <span class="pl-k">=</span> run.tournament(<span class="pl-v">tourn</span><span class="pl-k">=</span><span class="pl-smi">tourn</span>, <span class="pl-v">R</span> <span class="pl-k">=</span> <span class="pl-c1">5</span>)
  set.storing(<span class="pl-c1">TRUE</span>)  
  <span class="pl-smi">tourn</span>

  <span class="pl-c"># save data</span>
  save.tournament(<span class="pl-smi">tourn</span>)

  <span class="pl-c"># Analyse tournament in web browser</span>
  show.tournament(<span class="pl-smi">tourn</span>)</pre></div>

<div class="highlight highlight-r"><pre>  set.storing(<span class="pl-c1">TRUE</span>)
  options(<span class="pl-v">width</span><span class="pl-k">=</span><span class="pl-c1">80</span>)</pre></div>

<p>The tournament consists of R rounds (here R=15). In every round, every strategy plays against each other strategy in a repeated game. Every strategy also plays against itself. For every pairing of two strategies, we then compute the average payoff of the strategies over all R rounds.</p>

<p>The <code>show.tournament</code> command in the last line opens a window in your webbrowser that allows to interactively analyse the results of the tournament. I will explain the different statistics and graphs in class.</p>

<h2>
<a id="user-content-5-criteria-for-winning" class="anchor" href="#5-criteria-for-winning" aria-hidden="true"><span class="octicon octicon-link"></span></a>5 Criteria for winning</h2>

<p>There are different ways how one can evaluate the performance of the submitted strategies and assign scores. I want to present the basic idea of some approaches. The exact scoring rules will differ in different tasks of the seminar and will be explained in the task descriptions during the course.</p>

<h3>
<a id="user-content-51-average-performance-against-all-strategies" class="anchor" href="#51-average-performance-against-all-strategies" aria-hidden="true"><span class="octicon octicon-link"></span></a>5.1 Average performance against all strategies</h3>

<p>In his original tournament Axelrod let each strategy play against each other several repeated games and the score of each strategy was simply its average payoff over all its matches. </p>

<h3>
<a id="user-content-52-evolutionary-dynamic-and-performance-in-weighted-population" class="anchor" href="#52-evolutionary-dynamic-and-performance-in-weighted-population" aria-hidden="true"><span class="octicon octicon-link"></span></a>5.2 Evolutionary dynamic and performance in weighted population</h3>

<p>Imagine we have a society that lasts for several generations and in each generation it has a big population. Each member of society has a strategy that it plays in the repeated game. So we can think of each strategy <code>s</code> having a share <code>share[s]</code> in the total population. Imagine individuals randomly meet each other and play the repeated game. The average score of a strategy shall be the average payoff of a strategy across all matches. Let $S$ be the set of all strategies. The score of a strategy s in a symmetric two player game in an infinitely large population is then given by</p>

<p>[
U[s] = \sum_{r \in S} \bar{u}[s,r] * share[r]
]<br>
where $\bar{u}[s,r]$ shall be the average payoff of strategy s when playing against strategy r. This means the score is an weighted average payoff of all matches of a strategy, where payoffs are weighted by the population weight of the other player's strategy. If all strategies have the same population shares then the score is computed in the same fashion as in Axelrod's original rule (see 5.1).</p>

<p>Instead of assuming that all strategies have the same population shares, it seems sensible that individuals are more likely to adopt strategies that are successful while dismissing unsuccessful strategies. We model this process with a simple "evolutionary" dynamic in which strategy shares evolve over generations. A strategy <code>s</code> grows from one generation to the next generation essentially by the following simple linear population dynamics formula:</p>

<pre><code>  size.next[s] = size[s] + alpha * (U[s]-U.mean) * size[s]
</code></pre>

<p><code>U.mean</code> is the weighted average of the scores <code>U[s]</code> of all strategies, weighted with the population shares of each strategy. Hence a strategy's size in the population grows if and only if it has a higher average payoff than the weighted average payoff in the population. Otherwise, the strategy shrinks. The shares of each strategy in the next generation are obtained by normalizing the resulting sizes to 1.</p>

<p>[
  share.next[s] = \frac {size.next[s]} {\sum_{r \in S} size.next[r]}
]</p>

<p>The parameter <code>alpha</code> controls the speed of evolution. We get smoother dynamics if we pick lower values of alpha but run for more generations. In the limit of <code>alpha -&gt; 0</code> we have the popular replicator dynamics (see <a href="http://en.wikipedia.org/wiki/Replicator_equation">http://en.wikipedia.org/wiki/Replicator_equation</a>). In practice, setting alpha too small has the drawback that computation will take longer.</p>

<p>We will determine the strategies' scores as follows: we will specify in the task a number of generations and an alpha and then run the evolutionary dynamic to get resulting population shares of each strategy. The scores of each strategy will then be computed using these population shares as weights.</p>

<p>The main motivation for adding this evolutionary dynamic before computing scores is that it gives you incentives to design strategies that shall perform well against well-performing strategies (including itself). Your strategy's score is now less affected by its perfomance against weird, low-performing strategies because those strategies will quickly shrink to low population shares.</p>

<p>We may also give bonus points directly for being successful in the evolutionary process, e.g. for being the strategy with the highest population share, or for strategies whose population share converges to 100% in the long run. </p>

<h3>
<a id="user-content-scoring-based-on-the-performance-and-stability-as-a-societys-social-norm" class="anchor" href="#scoring-based-on-the-performance-and-stability-as-a-societys-social-norm" aria-hidden="true"><span class="octicon octicon-link"></span></a>Scoring based on the performance and stability as a society's social norm</h3>

<p>What would be a <strong>"good social norm"</strong> that one could teach to all people and which describes how they should behave in their interactions? More compactly:</p>

<p>** We search for strategies that would be efficient and evolutionary stable social norms if initially almost everybody would follow these strategies**</p>

<p>... to be continued ...</p>

<h2>
<a id="user-content-6-guidelines-for-your-strategies" class="anchor" href="#6-guidelines-for-your-strategies" aria-hidden="true"><span class="octicon octicon-link"></span></a>6. Guidelines for your Strategies</h2>

<h3>
<a id="user-content-keep-it-sufficiently-simple-intuitive-clean-and-fast" class="anchor" href="#keep-it-sufficiently-simple-intuitive-clean-and-fast" aria-hidden="true"><span class="octicon octicon-link"></span></a>Keep it sufficiently simple, intuitive, clean and fast</h3>

<p>Your strategies and the implementation as R should be intuitively understandable. It is not the goal to develop extremely complex strategies with a large number of states that nobody understands and that require extremely complicated computations. Also take into account that for the simulations we may run your strategy on the order of a million times, so don't make any complicated computations that need very long to run. That being said your strategy does not have to be as simple as tit-for-tat.</p>

<h3>
<a id="user-content-dont-cheat" class="anchor" href="#dont-cheat" aria-hidden="true"><span class="octicon octicon-link"></span></a>Don't cheat</h3>

<p>If you are a hacker, you may think of many ways to cheat. For example, it might be really useful to find out whether your strategy plays against itself, but the rules of the basic PD game don't give you an effective way to communicate (you can only choose C or D). So you may think of exchanging information by writing information into a global R variable which the other player can read out. Such things are considered cheating and <strong>not allowed</strong>.</p>

<ul class="task-list">
<li>You are only allowed to use the information that is passed to the function as parameters (including the states you returned in earlier periods).</li>
<li>You are not allowed to modify any external objects.</li>
</ul>

<p>As a rule of thumb: if you wonder whether something is cheating it probably is; if you are not sure ask us.</p>

<h2>
<a id="user-content-7-debugging-a-strategy" class="anchor" href="#7-debugging-a-strategy" aria-hidden="true"><span class="octicon octicon-link"></span></a>7. Debugging a strategy</h2>

<p>When you first write a strategy or other R function, it often does not work correctly: your function is likely to have bugs. Some bugs make your programm stop and throw an error message, other bugs are more subtle and make your strategy behave in a different fashion than you expected. <em>Debugging</em> means to find and correct bugs in your code. There are different tools that help debugging. I want to illustrate some debugging steps with an example.</p>

<p>Consider the following strategy, which I call "exploiter":</p>

<ul class="task-list">
<li>Exploiter: In the first period cooperate. If the other player cooperates for two or more times in a row defect. Otherwise play with 70% probability tit-for-tat and with 30% probability play defect. </li>
</ul>

<p>Here is a first attempt to implement this strategy as an r function (it contains a lot of bugs):</p>

<div class="highlight highlight-r"><pre><span class="pl-v">exploiter</span> <span class="pl-k">=</span> <span class="pl-k">function</span>(<span class="pl-smi">obs</span>,<span class="pl-smi">i</span>,<span class="pl-smi">t</span>,<span class="pl-smi">game</span>, <span class="pl-smi">otherC</span>) {
  debug.store(<span class="pl-s"><span class="pl-pds">"</span>exploiter<span class="pl-pds">"</span></span>,<span class="pl-smi">i</span>,<span class="pl-smi">t</span>) <span class="pl-c"># Store each call for each player</span>
  debug.restore(<span class="pl-s"><span class="pl-pds">"</span>exploiter<span class="pl-pds">"</span></span>,<span class="pl-v">i</span><span class="pl-k">=</span><span class="pl-c1">1</span>,<span class="pl-v">t</span><span class="pl-k">=</span><span class="pl-c1">2</span>) <span class="pl-c"># Restore call for player i in period t</span>

  <span class="pl-c"># Start nice in first period</span>
  <span class="pl-k">if</span> (<span class="pl-v">t</span><span class="pl-k">=</span><span class="pl-c1">1</span>) {
    <span class="pl-k">return</span>(<span class="pl-k">list</span>(<span class="pl-v">a</span><span class="pl-k">=</span><span class="pl-s"><span class="pl-pds">"</span>C<span class="pl-pds">"</span></span>,<span class="pl-v">otherC</span><span class="pl-k">=</span><span class="pl-c1">0</span>))
  }
  <span class="pl-c"># If the other player has chosen C two or more times in a row play D</span>
  <span class="pl-k">if</span> (<span class="pl-smi">obs</span><span class="pl-k">$</span><span class="pl-smi">a</span>[[<span class="pl-smi">j</span>]]<span class="pl-k">==</span><span class="pl-s"><span class="pl-pds">"</span>C<span class="pl-pds">"</span></span>) <span class="pl-v">otherC</span><span class="pl-k">=</span> <span class="pl-smi">otherC</span> <span class="pl-k">+</span> <span class="pl-c1">1</span>

  <span class="pl-k">if</span> (<span class="pl-smi">otherC</span> <span class="pl-k">&gt;</span> <span class="pl-c1">2</span>) <span class="pl-k">return</span>(<span class="pl-k">list</span>(<span class="pl-v">a</span><span class="pl-k">=</span><span class="pl-s"><span class="pl-pds">"</span>D<span class="pl-pds">"</span></span>))

  <span class="pl-c"># Play tit for tat with probability 70% and with prob. 30% play D</span>
  <span class="pl-k">if</span> (runif(<span class="pl-c1">1</span>)<span class="pl-k">&lt;</span><span class="pl-c1">70</span>) {
    <span class="pl-v">a</span> <span class="pl-k">=</span> <span class="pl-smi">obs</span><span class="pl-k">$</span><span class="pl-smi">a</span>[[<span class="pl-smi">j</span>]]
  } <span class="pl-k">else</span> {
    <span class="pl-v">a</span> <span class="pl-k">=</span> <span class="pl-s"><span class="pl-pds">"</span>D<span class="pl-pds">"</span></span>
  }
  <span class="pl-k">return</span>(nlist(<span class="pl-v">a</span><span class="pl-k">=</span><span class="pl-smi">a</span>,<span class="pl-smi">otherC</span>))
}
</pre></div>

<h3>
<a id="user-content-step-1-run-function-definition-in-r-console-and-correct-errors" class="anchor" href="#step-1-run-function-definition-in-r-console-and-correct-errors" aria-hidden="true"><span class="octicon octicon-link"></span></a>Step 1: Run function definition in R console and correct errors</h3>

<p>As a first step select the whole function in the RStudio editor and press the run button. You should see something similar to the following in the R console.</p>

<pre><code>&gt; exploiter = function(obs,i,t, other.weakness, ...) {
+  debug.store("exploiter",i,t) # Store each call for each player
+  debug.restore("exploiter",i=1,t=2) # Restore call for player i in period t
+  if (t=1) {
Error: unexpected '=' in:
"exploiter = function(obs,i,t,game, other.weakness) {
  if (t="
&gt;     return(list(a="C",other.weakness=0))
Error: no function to return from, jumping to top level
&gt;   }
Error: unexpected '}' in "  }"
&gt;   if (obs$a[[j]]=="C") {
+     other.weakness = other.weakness + 1
+   }
Error: object 'j' not found
&gt;   if (other.weakness &gt; 2) {
+     return(list(a="D"))
+   }
Error: object 'other.weakness' not found
&gt;   # Follow tit for tat with probability 70% otherwise play D
&gt;   a = ifelse(runif(1)&lt;0.7,obs$a[[j]],"D")
Error in ifelse(runif(1) &lt; 0.7, obs$a[[j]], "D") : object 'j' not found
&gt;   return(nlist(a=a,other.weakness))
Error in nlist(a = a, other.weakness) : object 'other.weakness' not found
&gt; }
Error: unexpected '}' in "}"
</code></pre>

<p>There are a lot of error messages. It is best to start with the first error message and try to correct the corresponding code.</p>

<pre><code>  if (t=1) {
  Error: unexpected '=' in:
  "exploiter = function(obs,i,t,game, other.weakness) {if (t="
</code></pre>

<p>This is a typical beginner error. If we want to check whether t is 1, we need to write <code>t==1</code> instead of <code>t=1</code>. (The expression <code>t=1</code> means that the value 1 is assigned to the variable t, expression <code>t==1</code> is a boolean expression that is TRUE if t is 1 and FALSE otherwise.)  A corrected version of the function is</p>

<div class="highlight highlight-r"><pre><span class="pl-v">exploiter</span> <span class="pl-k">=</span> <span class="pl-k">function</span>(<span class="pl-smi">obs</span>,<span class="pl-smi">i</span>,<span class="pl-smi">t</span>, <span class="pl-smi">otherC</span>,<span class="pl-k">...</span>) {
  debug.store(<span class="pl-s"><span class="pl-pds">"</span>exploiter<span class="pl-pds">"</span></span>,<span class="pl-smi">i</span>,<span class="pl-smi">t</span>) <span class="pl-c"># Store each call for each player</span>
  debug.restore(<span class="pl-s"><span class="pl-pds">"</span>exploiter<span class="pl-pds">"</span></span>,<span class="pl-v">i</span><span class="pl-k">=</span><span class="pl-c1">1</span>,<span class="pl-v">t</span><span class="pl-k">=</span><span class="pl-c1">2</span>) <span class="pl-c"># Restore call for player i in period t</span>


  <span class="pl-c"># Start nice in first period</span>
  <span class="pl-k">if</span> (<span class="pl-smi">t</span><span class="pl-k">==</span><span class="pl-c1">1</span>) {
    <span class="pl-k">return</span>(<span class="pl-k">list</span>(<span class="pl-v">a</span><span class="pl-k">=</span><span class="pl-s"><span class="pl-pds">"</span>C<span class="pl-pds">"</span></span>,<span class="pl-v">otherC</span><span class="pl-k">=</span><span class="pl-c1">0</span>))
  }
  <span class="pl-c"># If the other player has chosen C two or more times in a row play D</span>
  <span class="pl-k">if</span> (<span class="pl-smi">obs</span><span class="pl-k">$</span><span class="pl-smi">a</span>[[<span class="pl-smi">j</span>]]<span class="pl-k">==</span><span class="pl-s"><span class="pl-pds">"</span>C<span class="pl-pds">"</span></span>) <span class="pl-v">otherC</span><span class="pl-k">=</span> <span class="pl-smi">otherC</span> <span class="pl-k">+</span> <span class="pl-c1">1</span>

  <span class="pl-k">if</span> (<span class="pl-smi">otherC</span> <span class="pl-k">&gt;</span> <span class="pl-c1">2</span>) <span class="pl-k">return</span>(<span class="pl-k">list</span>(<span class="pl-v">a</span><span class="pl-k">=</span><span class="pl-s"><span class="pl-pds">"</span>D<span class="pl-pds">"</span></span>))

  <span class="pl-c"># Play tit for tat with probability 70% and with prob. 30% play D</span>
  <span class="pl-k">if</span> (runif(<span class="pl-c1">1</span>)<span class="pl-k">&lt;</span><span class="pl-c1">70</span>) {
    <span class="pl-v">a</span> <span class="pl-k">=</span> <span class="pl-smi">obs</span><span class="pl-k">$</span><span class="pl-smi">a</span>[[<span class="pl-smi">j</span>]]
  } <span class="pl-k">else</span> {
    <span class="pl-v">a</span> <span class="pl-k">=</span> <span class="pl-s"><span class="pl-pds">"</span>D<span class="pl-pds">"</span></span>
  }
  <span class="pl-k">return</span>(nlist(<span class="pl-v">a</span><span class="pl-k">=</span><span class="pl-smi">a</span>,<span class="pl-smi">otherC</span>))
}
</pre></div>

<p>If you run this new version in the console, no error is shown. Unfortunately, this does not mean that there</p>

<h3>
<a id="user-content-step-2-check-whether-runrepgame-yields-errors-and-debug-such-errors-by-stepping-trough-function" class="anchor" href="#step-2-check-whether-runrepgame-yields-errors-and-debug-such-errors-by-stepping-trough-function" aria-hidden="true"><span class="octicon octicon-link"></span></a>Step 2: Check whether run.rep.game yields errors and debug such errors by stepping trough function</h3>

<p>As next step let us run run.rep.game with the strategy and check whether some errors are shown.</p>

<div class="highlight highlight-r"><pre>  run.rep.game(<span class="pl-v">delta</span><span class="pl-k">=</span><span class="pl-c1">0.95</span>, <span class="pl-v">game</span><span class="pl-k">=</span><span class="pl-smi">game</span>, <span class="pl-v">strat</span> <span class="pl-k">=</span> nlist(<span class="pl-smi">exploiter</span>,<span class="pl-smi">random.action</span>))</pre></div>

<p>We get an error message and learn that an error occurred when calling exploiter for player i=1 in period t=2. We also get the error message "object 'j' not found". Probably you see the problem directly from that message. Nevertheless, let us pretend we have not found the problem yet and let us step through our function.
Go to the function code and run the line</p>

<div class="highlight highlight-r"><pre>debug.restore(<span class="pl-s"><span class="pl-pds">"</span>exploiter<span class="pl-pds">"</span></span>,<span class="pl-v">i</span><span class="pl-k">=</span><span class="pl-c1">1</span>,<span class="pl-v">t</span><span class="pl-k">=</span><span class="pl-c1">2</span>) <span class="pl-c"># Restore call for player i in period t</span></pre></div>

<p>in the R console by selecting the line and pressing the "Run" button or Ctrl-Enter. This call now restores now the arguments with which the strategy has been called  for player i=1 in period t=2. You can examine the function arguments by typing them in the R console:</p>

<div class="highlight highlight-r"><pre><span class="pl-smi">obs</span>
<span class="pl-smi">i</span>
<span class="pl-smi">t</span></pre></div>

<p>You can also run some further lines of code inside the function to see where exactly the error has occured:</p>

<div class="highlight highlight-r"><pre>  <span class="pl-c"># Start nice in first period</span>
  <span class="pl-k">if</span> (<span class="pl-smi">t</span><span class="pl-k">==</span><span class="pl-c1">1</span>) {
    <span class="pl-k">return</span>(<span class="pl-k">list</span>(<span class="pl-v">a</span><span class="pl-k">=</span><span class="pl-s"><span class="pl-pds">"</span>C<span class="pl-pds">"</span></span>,<span class="pl-v">otherC</span><span class="pl-k">=</span><span class="pl-c1">0</span>))
  }
  <span class="pl-c"># If the other player has chosen C two or more times in a row play D</span>
  <span class="pl-k">if</span> (<span class="pl-smi">obs</span><span class="pl-k">$</span><span class="pl-smi">a</span>[[<span class="pl-smi">j</span>]]<span class="pl-k">==</span><span class="pl-s"><span class="pl-pds">"</span>C<span class="pl-pds">"</span></span>) <span class="pl-v">otherC</span><span class="pl-k">=</span> <span class="pl-smi">otherC</span> <span class="pl-k">+</span> <span class="pl-c1">1</span></pre></div>

<p>We can also run parts of the last line to narrow down the error...</p>

<div class="highlight highlight-r"><pre>  <span class="pl-smi">obs</span><span class="pl-k">$</span><span class="pl-smi">a</span>[[<span class="pl-smi">j</span>]]
  <span class="pl-smi">j</span></pre></div>

<p>Ok, clearly we forgot to define the variable j, which shall be the index of the other player. We can add the line j = 3-i and run again the code inside the corrected function:</p>

<div class="highlight highlight-r"><pre>  debug.restore(<span class="pl-s"><span class="pl-pds">"</span>exploiter<span class="pl-pds">"</span></span>,<span class="pl-v">i</span><span class="pl-k">=</span><span class="pl-c1">1</span>,<span class="pl-v">t</span><span class="pl-k">=</span><span class="pl-c1">2</span>) <span class="pl-c"># Restore call for player i in period t</span>
  <span class="pl-c"># Start nice in first period</span>
  <span class="pl-k">if</span> (<span class="pl-smi">t</span><span class="pl-k">==</span><span class="pl-c1">1</span>) {
    <span class="pl-k">return</span>(<span class="pl-k">list</span>(<span class="pl-v">a</span><span class="pl-k">=</span><span class="pl-s"><span class="pl-pds">"</span>C<span class="pl-pds">"</span></span>,<span class="pl-v">otherC</span><span class="pl-k">=</span><span class="pl-c1">0</span>))
  }
  <span class="pl-v">j</span> <span class="pl-k">=</span> <span class="pl-c1">3</span><span class="pl-k">-</span><span class="pl-smi">i</span> <span class="pl-c"># index of other player</span>

  <span class="pl-c"># If the other player has chosen C two or more times in a row play D</span>
  <span class="pl-k">if</span> (<span class="pl-smi">obs</span><span class="pl-k">$</span><span class="pl-smi">a</span>[[<span class="pl-smi">j</span>]]<span class="pl-k">==</span><span class="pl-s"><span class="pl-pds">"</span>C<span class="pl-pds">"</span></span>) <span class="pl-v">otherC</span><span class="pl-k">=</span> <span class="pl-smi">otherC</span> <span class="pl-k">+</span> <span class="pl-c1">1</span>
  <span class="pl-k">if</span> (<span class="pl-smi">otherC</span> <span class="pl-k">&gt;</span> <span class="pl-c1">2</span>) <span class="pl-k">return</span>(<span class="pl-k">list</span>(<span class="pl-v">a</span><span class="pl-k">=</span><span class="pl-s"><span class="pl-pds">"</span>D<span class="pl-pds">"</span></span>))

  <span class="pl-c"># Play tit for tat with probability 70% and with prob. 30% play D</span>
  <span class="pl-k">if</span> (runif(<span class="pl-c1">1</span>)<span class="pl-k">&lt;</span><span class="pl-c1">70</span>) {
    <span class="pl-v">a</span> <span class="pl-k">=</span> <span class="pl-smi">obs</span><span class="pl-k">$</span><span class="pl-smi">a</span>[[<span class="pl-smi">j</span>]]
  } <span class="pl-k">else</span> {
    <span class="pl-v">a</span> <span class="pl-k">=</span> <span class="pl-s"><span class="pl-pds">"</span>D<span class="pl-pds">"</span></span>
  }
  <span class="pl-k">return</span>(nlist(<span class="pl-v">a</span><span class="pl-k">=</span><span class="pl-smi">a</span>,<span class="pl-smi">otherC</span>))</pre></div>

<p>You probably will see an error message after the last line that there is no function to return from, but we can ignore that one. Otherwise we see no more error. Yet, that does not mean that our function has no more bug.
Before proceeding we copy the whole corrected function definition into the R console:</p>

<div class="highlight highlight-r"><pre><span class="pl-v">exploiter</span> <span class="pl-k">=</span> <span class="pl-k">function</span>(<span class="pl-smi">obs</span>,<span class="pl-smi">i</span>,<span class="pl-smi">t</span>, <span class="pl-smi">otherC</span>,<span class="pl-k">...</span>) {
  debug.store(<span class="pl-s"><span class="pl-pds">"</span>exploiter<span class="pl-pds">"</span></span>,<span class="pl-smi">i</span>,<span class="pl-smi">t</span>) <span class="pl-c"># Store each call for each player</span>
  debug.restore(<span class="pl-s"><span class="pl-pds">"</span>exploiter<span class="pl-pds">"</span></span>,<span class="pl-v">i</span><span class="pl-k">=</span><span class="pl-c1">1</span>,<span class="pl-v">t</span><span class="pl-k">=</span><span class="pl-c1">2</span>) <span class="pl-c"># Restore call for player i in period t</span>

  <span class="pl-c"># Start nice in first period</span>
  <span class="pl-k">if</span> (<span class="pl-smi">t</span><span class="pl-k">==</span><span class="pl-c1">1</span>) {
    <span class="pl-k">return</span>(<span class="pl-k">list</span>(<span class="pl-v">a</span><span class="pl-k">=</span><span class="pl-s"><span class="pl-pds">"</span>C<span class="pl-pds">"</span></span>,<span class="pl-v">otherC</span><span class="pl-k">=</span><span class="pl-c1">0</span>))
  }
  <span class="pl-v">j</span> <span class="pl-k">=</span> <span class="pl-c1">3</span><span class="pl-k">-</span><span class="pl-smi">i</span> <span class="pl-c"># index of other player</span>

  <span class="pl-c"># If the other player has chosen C two or more times in a row play D</span>
  <span class="pl-k">if</span> (<span class="pl-smi">obs</span><span class="pl-k">$</span><span class="pl-smi">a</span>[[<span class="pl-smi">j</span>]]<span class="pl-k">==</span><span class="pl-s"><span class="pl-pds">"</span>C<span class="pl-pds">"</span></span>) <span class="pl-v">otherC</span><span class="pl-k">=</span> <span class="pl-smi">otherC</span> <span class="pl-k">+</span> <span class="pl-c1">1</span>
  <span class="pl-k">if</span> (<span class="pl-smi">otherC</span> <span class="pl-k">&gt;</span> <span class="pl-c1">2</span>) <span class="pl-k">return</span>(<span class="pl-k">list</span>(<span class="pl-v">a</span><span class="pl-k">=</span><span class="pl-s"><span class="pl-pds">"</span>D<span class="pl-pds">"</span></span>))

  <span class="pl-c"># Play tit for tat with probability 70% and with prob. 30% play D</span>
  <span class="pl-k">if</span> (runif(<span class="pl-c1">1</span>)<span class="pl-k">&lt;</span><span class="pl-c1">70</span>) {
    <span class="pl-v">a</span> <span class="pl-k">=</span> <span class="pl-smi">obs</span><span class="pl-k">$</span><span class="pl-smi">a</span>[[<span class="pl-smi">j</span>]]
  } <span class="pl-k">else</span> {
    <span class="pl-v">a</span> <span class="pl-k">=</span> <span class="pl-s"><span class="pl-pds">"</span>D<span class="pl-pds">"</span></span>
  }
  <span class="pl-k">return</span>(nlist(<span class="pl-v">a</span><span class="pl-k">=</span><span class="pl-smi">a</span>,<span class="pl-smi">otherC</span>))
}
</pre></div>

<h3>
<a id="user-content-step-3-running-runrepgame-again-and-debugging-the-next-error" class="anchor" href="#step-3-running-runrepgame-again-and-debugging-the-next-error" aria-hidden="true"><span class="octicon octicon-link"></span></a>Step 3: Running run.rep.game again and debugging the next error</h3>

<p>Copy the corrected function in your R console and then call run.rep.game again. (Note I now call the function run.rep.game with the parameters game.seed and strat.seed, which ensure that the random generator always returns the same results. That is just for the reason that it is easier to write this documentation if the error always occures in the same period).</p>

<div class="highlight highlight-r"><pre>  run.rep.game(<span class="pl-v">delta</span><span class="pl-k">=</span><span class="pl-c1">0.95</span>, <span class="pl-v">game</span><span class="pl-k">=</span><span class="pl-smi">game</span>, <span class="pl-v">strat</span> <span class="pl-k">=</span> nlist(<span class="pl-smi">exploiter</span>,<span class="pl-smi">random.action</span>), <span class="pl-v">game.seed</span><span class="pl-k">=</span><span class="pl-c1">12345</span>, <span class="pl-v">strat.seed</span><span class="pl-k">=</span><span class="pl-c1">12345</span>)</pre></div>

<p>We find an error in period t=10 . Let us investigate the call to our strategy in that period by setting t=10 in the call to debug.restore</p>

<div class="highlight highlight-r"><pre>  debug.restore(<span class="pl-s"><span class="pl-pds">"</span>exploiter<span class="pl-pds">"</span></span>,<span class="pl-v">i</span><span class="pl-k">=</span><span class="pl-c1">1</span>,<span class="pl-v">t</span><span class="pl-k">=</span><span class="pl-c1">10</span>) <span class="pl-c"># Restore call for player i in period t</span></pre></div>

<p>The call tells me that the state variable otherC was not provided as an argument to this function. This basically means that in period t=9 the function did not return the variable otherC. Let us check where this problem happened by exploring in more detail the function call in period 9.</p>

<div class="highlight highlight-r"><pre>  debug.restore(<span class="pl-s"><span class="pl-pds">"</span>exploiter<span class="pl-pds">"</span></span>,<span class="pl-v">i</span><span class="pl-k">=</span><span class="pl-c1">1</span>,<span class="pl-v">t</span><span class="pl-k">=</span><span class="pl-c1">9</span>) <span class="pl-c"># Restore call for player i in period t</span>

  <span class="pl-c"># Start nice in first period</span>
  <span class="pl-k">if</span> (<span class="pl-smi">t</span><span class="pl-k">==</span><span class="pl-c1">1</span>) {
    <span class="pl-k">return</span>(<span class="pl-k">list</span>(<span class="pl-v">a</span><span class="pl-k">=</span><span class="pl-s"><span class="pl-pds">"</span>C<span class="pl-pds">"</span></span>,<span class="pl-v">otherC</span><span class="pl-k">=</span><span class="pl-c1">0</span>))
  }
  <span class="pl-v">j</span> <span class="pl-k">=</span> <span class="pl-c1">3</span><span class="pl-k">-</span><span class="pl-smi">i</span> <span class="pl-c"># index of other player</span>

  <span class="pl-c"># If the other player has chosen C two or more times in a row play D</span>
  <span class="pl-k">if</span> (<span class="pl-smi">obs</span><span class="pl-k">$</span><span class="pl-smi">a</span>[[<span class="pl-smi">j</span>]]<span class="pl-k">==</span><span class="pl-s"><span class="pl-pds">"</span>C<span class="pl-pds">"</span></span>) <span class="pl-v">otherC</span><span class="pl-k">=</span> <span class="pl-smi">otherC</span> <span class="pl-k">+</span> <span class="pl-c1">1</span>
  <span class="pl-k">if</span> (<span class="pl-smi">otherC</span> <span class="pl-k">&gt;</span> <span class="pl-c1">2</span>) <span class="pl-k">return</span>(<span class="pl-k">list</span>(<span class="pl-v">a</span><span class="pl-k">=</span><span class="pl-s"><span class="pl-pds">"</span>D<span class="pl-pds">"</span></span>))
</pre></div>

<pre><code>Error: no function to return from, jumping to top level
</code></pre>

<p>We see that the function returned in the last line of the code above. And of course, we forgot to add otherC in the list of returned variables. So this variable was missing in period t=10. The last line is easy to fix and we again paste into the R console a corrected version of our strategy:</p>

<div class="highlight highlight-r"><pre><span class="pl-v">exploiter</span> <span class="pl-k">=</span> <span class="pl-k">function</span>(<span class="pl-smi">obs</span>,<span class="pl-smi">i</span>,<span class="pl-smi">t</span>, <span class="pl-smi">otherC</span>,<span class="pl-k">...</span>) {
  debug.store(<span class="pl-s"><span class="pl-pds">"</span>exploiter<span class="pl-pds">"</span></span>,<span class="pl-smi">i</span>,<span class="pl-smi">t</span>) <span class="pl-c"># Store each call for each player</span>
  debug.restore(<span class="pl-s"><span class="pl-pds">"</span>exploiter<span class="pl-pds">"</span></span>,<span class="pl-v">i</span><span class="pl-k">=</span><span class="pl-c1">1</span>,<span class="pl-v">t</span><span class="pl-k">=</span><span class="pl-c1">2</span>) <span class="pl-c"># Restore call for player i in period t</span>

  <span class="pl-c"># Start nice in first period</span>
  <span class="pl-k">if</span> (<span class="pl-smi">t</span><span class="pl-k">==</span><span class="pl-c1">1</span>) {
    <span class="pl-k">return</span>(<span class="pl-k">list</span>(<span class="pl-v">a</span><span class="pl-k">=</span><span class="pl-s"><span class="pl-pds">"</span>C<span class="pl-pds">"</span></span>,<span class="pl-v">otherC</span><span class="pl-k">=</span><span class="pl-c1">0</span>))
  }
  <span class="pl-v">j</span> <span class="pl-k">=</span> <span class="pl-c1">3</span><span class="pl-k">-</span><span class="pl-smi">i</span> <span class="pl-c"># index of other player</span>

  <span class="pl-c"># If the other player has chosen C two or more times in a row play D</span>
  <span class="pl-k">if</span> (<span class="pl-smi">obs</span><span class="pl-k">$</span><span class="pl-smi">a</span>[[<span class="pl-smi">j</span>]]<span class="pl-k">==</span><span class="pl-s"><span class="pl-pds">"</span>C<span class="pl-pds">"</span></span>) <span class="pl-v">otherC</span><span class="pl-k">=</span> <span class="pl-smi">otherC</span> <span class="pl-k">+</span> <span class="pl-c1">1</span>
  <span class="pl-k">if</span> (<span class="pl-smi">otherC</span> <span class="pl-k">&gt;</span> <span class="pl-c1">2</span>) <span class="pl-k">return</span>(<span class="pl-k">list</span>(<span class="pl-v">a</span><span class="pl-k">=</span><span class="pl-s"><span class="pl-pds">"</span>D<span class="pl-pds">"</span></span>,<span class="pl-v">otherC</span><span class="pl-k">=</span><span class="pl-smi">otherC</span>))

  <span class="pl-c"># Play tit for tat with probability 70% and with prob. 30% play D</span>
  <span class="pl-k">if</span> (runif(<span class="pl-c1">1</span>)<span class="pl-k">&lt;</span><span class="pl-c1">70</span>) {
    <span class="pl-v">a</span> <span class="pl-k">=</span> <span class="pl-smi">obs</span><span class="pl-k">$</span><span class="pl-smi">a</span>[[<span class="pl-smi">j</span>]]
  } <span class="pl-k">else</span> {
    <span class="pl-v">a</span> <span class="pl-k">=</span> <span class="pl-s"><span class="pl-pds">"</span>D<span class="pl-pds">"</span></span>
  }
  <span class="pl-k">return</span>(nlist(<span class="pl-v">a</span><span class="pl-k">=</span><span class="pl-smi">a</span>,<span class="pl-smi">otherC</span>))
}
</pre></div>

<h3>
<a id="user-content-step-4-call-runrepgame-again-and-remove-remaining-bugs" class="anchor" href="#step-4-call-runrepgame-again-and-remove-remaining-bugs" aria-hidden="true"><span class="octicon octicon-link"></span></a>Step 4: Call run.rep.game again and remove remaining bugs</h3>

<div class="highlight highlight-r"><pre>  run.rep.game(<span class="pl-v">delta</span><span class="pl-k">=</span><span class="pl-c1">0.95</span>, <span class="pl-v">game</span><span class="pl-k">=</span><span class="pl-smi">game</span>, <span class="pl-v">strat</span> <span class="pl-k">=</span> nlist(<span class="pl-smi">exploiter</span>,<span class="pl-smi">random.action</span>), <span class="pl-v">game.seed</span><span class="pl-k">=</span><span class="pl-c1">12345</span>, <span class="pl-v">strat.seed</span><span class="pl-k">=</span><span class="pl-c1">12345</span>)</pre></div>

<p>There is no more error message but there are still 2 bugs left in the function such that the programmed strategy does not work as verbally described. (Remember that the strategy shall only automatically defect if at last two times <strong>in a row</strong> the other player has played C). I will leave the debugging of the last function as an exercise. I just end with a little debugging hint. It can be useful to define additional helper states so that one gets better information in the result table. For example, I add a state "played.tit.for.tat" that is TRUE if the function exploiter indeed played tit.for.tat in the current round and otherwise will be shown as FALSE: (For the state to appear in the table, it must be returned in the first period)</p>

<div class="highlight highlight-r"><pre><span class="pl-v">exploiter</span> <span class="pl-k">=</span> <span class="pl-k">function</span>(<span class="pl-smi">obs</span>,<span class="pl-smi">i</span>,<span class="pl-smi">t</span>, <span class="pl-smi">otherC</span>, <span class="pl-v">played.tit.for.tat</span><span class="pl-k">=</span><span class="pl-c1">FALSE</span>,<span class="pl-k">...</span>) {
  debug.store(<span class="pl-s"><span class="pl-pds">"</span>exploiter<span class="pl-pds">"</span></span>,<span class="pl-smi">i</span>,<span class="pl-smi">t</span>) <span class="pl-c"># Store each call for each player</span>
  debug.restore(<span class="pl-s"><span class="pl-pds">"</span>exploiter<span class="pl-pds">"</span></span>,<span class="pl-v">i</span><span class="pl-k">=</span><span class="pl-c1">1</span>,<span class="pl-v">t</span><span class="pl-k">=</span><span class="pl-c1">2</span>) <span class="pl-c"># Restore call for player i in period t</span>

  <span class="pl-c"># Start nice in first period</span>
  <span class="pl-k">if</span> (<span class="pl-smi">t</span><span class="pl-k">==</span><span class="pl-c1">1</span>) {
    <span class="pl-k">return</span>(nlist(<span class="pl-v">a</span><span class="pl-k">=</span><span class="pl-s"><span class="pl-pds">"</span>C<span class="pl-pds">"</span></span>,<span class="pl-v">otherC</span><span class="pl-k">=</span><span class="pl-c1">0</span>, <span class="pl-smi">played.tit.for.tat</span>))
  }
  <span class="pl-v">j</span> <span class="pl-k">=</span> <span class="pl-c1">3</span><span class="pl-k">-</span><span class="pl-smi">i</span> <span class="pl-c"># index of other player</span>

  <span class="pl-c"># If the other player has chosen C two or more times in a row play D</span>
  <span class="pl-k">if</span> (<span class="pl-smi">obs</span><span class="pl-k">$</span><span class="pl-smi">a</span>[[<span class="pl-smi">j</span>]]<span class="pl-k">==</span><span class="pl-s"><span class="pl-pds">"</span>C<span class="pl-pds">"</span></span>) <span class="pl-v">otherC</span><span class="pl-k">=</span> <span class="pl-smi">otherC</span> <span class="pl-k">+</span> <span class="pl-c1">1</span>
  <span class="pl-k">if</span> (<span class="pl-smi">otherC</span> <span class="pl-k">&gt;</span> <span class="pl-c1">2</span>) <span class="pl-k">return</span>(nlist(<span class="pl-v">a</span><span class="pl-k">=</span><span class="pl-s"><span class="pl-pds">"</span>D<span class="pl-pds">"</span></span>,<span class="pl-v">otherC</span><span class="pl-k">=</span><span class="pl-smi">otherC</span>, <span class="pl-smi">played.tit.for.tat</span>))

  <span class="pl-c"># Play tit for tat with probability 70% and with prob. 30% play D</span>
  <span class="pl-k">if</span> (runif(<span class="pl-c1">1</span>)<span class="pl-k">&lt;</span><span class="pl-c1">70</span>) {
    <span class="pl-v">a</span> <span class="pl-k">=</span> <span class="pl-smi">obs</span><span class="pl-k">$</span><span class="pl-smi">a</span>[[<span class="pl-smi">j</span>]]
    <span class="pl-v">played.tit.for.tat</span> <span class="pl-k">=</span> <span class="pl-c1">TRUE</span>
  } <span class="pl-k">else</span> {
    <span class="pl-v">a</span> <span class="pl-k">=</span> <span class="pl-s"><span class="pl-pds">"</span>D<span class="pl-pds">"</span></span>
    <span class="pl-v">played.tit.for.tat</span> <span class="pl-k">=</span> <span class="pl-c1">FALSE</span>
  }
  <span class="pl-k">return</span>(nlist(<span class="pl-v">a</span><span class="pl-k">=</span><span class="pl-smi">a</span>,<span class="pl-smi">otherC</span>, <span class="pl-smi">played.tit.for.tat</span>))
}

run.rep.game(<span class="pl-v">delta</span><span class="pl-k">=</span><span class="pl-c1">0.95</span>, <span class="pl-v">game</span><span class="pl-k">=</span><span class="pl-smi">game</span>, <span class="pl-v">strat</span> <span class="pl-k">=</span> nlist(<span class="pl-smi">exploiter</span>,<span class="pl-smi">random.action</span>), <span class="pl-v">game.seed</span><span class="pl-k">=</span><span class="pl-c1">12345</span>, <span class="pl-v">strat.seed</span><span class="pl-k">=</span><span class="pl-c1">12345</span>)
</pre></div>

<h3>
<a id="user-content-exercise-correct-the-remaining-bugs-in-exploiter" class="anchor" href="#exercise-correct-the-remaining-bugs-in-exploiter" aria-hidden="true"><span class="octicon octicon-link"></span></a>Exercise: Correct the remaining bugs in exploiter</h3>

<p>That was the tutorial. Take at the look at the upcoming problem sets that will describe the tournament tasks...</p>

<h2>
<a id="user-content-8-studying-candidates-for-good-strategies-fine-tuning-the-parameters" class="anchor" href="#8-studying-candidates-for-good-strategies-fine-tuning-the-parameters" aria-hidden="true"><span class="octicon octicon-link"></span></a>8 Studying candidates for good strategies: fine-tuning the parameters</h2>

<p>(Section will be revised)</p>

<p>The package StratTourn contains the function <code>study.strats.and.answers</code> that can help to find promising strategies. </p>

<p>The development of strategies (or best answers) often involves two steps:</p>

<ol class="task-list">
<li>You develop a general idea of a strategy, which often involes some numeric parameters that affect the probability to cooperate or defect in certain situations.</li>
<li>You fine-tune the parameters of your strategy for the given scenarios</li>
</ol>

<p>Fine tuning means in the first stage that you want to find parameters that increase efficiency and stability of your strategy. In the second stage you want to find parameters for your answer strategy that allow the biggest stabilization of the original strategy. The function study.strats.and.answers can be helpful for both tasks.</p>

<h2>
<a id="user-content-studystratsandanswers" class="anchor" href="#studystratsandanswers" aria-hidden="true"><span class="octicon octicon-link"></span></a>study.strats.and.answers</h2>

<div class="highlight highlight-r"><pre>  library(<span class="pl-smi">StratTourn</span>)
  library(<span class="pl-smi">compiler</span>)</pre></div>

<p>To illustrat, the function, we define a simple strategy called <strong>mix</strong> which randomly chooses "C" or "D".</p>

<div class="highlight highlight-r"><pre>  <span class="pl-v">mix</span> <span class="pl-k">=</span> <span class="pl-k">function</span>(<span class="pl-smi">obs</span>,<span class="pl-smi">t</span>,<span class="pl-smi">i</span>, <span class="pl-v">probC</span> <span class="pl-k">=</span> <span class="pl-c1">0.5</span>, <span class="pl-k">...</span>) {
    <span class="pl-k">if</span> (runif(<span class="pl-c1">1</span>)<span class="pl-k">&lt;</span><span class="pl-k">=</span><span class="pl-smi">probC</span>) <span class="pl-k">return</span>(nlist(<span class="pl-v">a</span><span class="pl-k">=</span><span class="pl-s"><span class="pl-pds">"</span>C<span class="pl-pds">"</span></span>))
    <span class="pl-k">return</span>(nlist(<span class="pl-v">a</span><span class="pl-k">=</span><span class="pl-s"><span class="pl-pds">"</span>D<span class="pl-pds">"</span></span>))
  }</pre></div>

<p>The function has parameter <strong>probC</strong> that specifies the probability to cooperate. W now graphically analyze the mean efficiency of this simple strategy class for different values of probC.</p>

<div class="highlight highlight-r"><pre>  library(<span class="pl-smi">StratTourn</span>)

  <span class="pl-c"># A PD game </span>
  <span class="pl-v">game</span> <span class="pl-k">=</span> make.pd.game()

  <span class="pl-v">sim</span> <span class="pl-k">=</span> <span class="pl-c1">NULL</span>
  <span class="pl-c"># Study efficiency of mix for different values of probC </span>
  <span class="pl-v">sim</span> <span class="pl-k">=</span> study.strats.and.answers(
    <span class="pl-v">strats</span> <span class="pl-k">=</span> nlist(<span class="pl-smi">mix</span>),
    <span class="pl-v">strat.par</span> <span class="pl-k">=</span> <span class="pl-k">list</span>(<span class="pl-v">probC</span> <span class="pl-k">=</span> seq(<span class="pl-c1">0</span>,<span class="pl-c1">1</span>,<span class="pl-v">length</span><span class="pl-k">=</span><span class="pl-c1">11</span>)),
    <span class="pl-v">R</span><span class="pl-k">=</span><span class="pl-c1">10</span>, <span class="pl-v">delta</span><span class="pl-k">=</span><span class="pl-c1">0.95</span>, <span class="pl-v">sim</span><span class="pl-k">=</span><span class="pl-smi">sim</span>,<span class="pl-v">game</span><span class="pl-k">=</span><span class="pl-smi">game</span>
  )
  plot(<span class="pl-smi">sim</span>)
</pre></div>

<p>You can call the function one more time to get more simulations, which will be added to the earlier simulations stored in sim. This reduces the sampling uncertainty. We also increase R from 10 to 50 to add 50 additional simulations instead of only 10.</p>

<div class="highlight highlight-r"><pre>  <span class="pl-c"># Study efficiency of mix for different values of probC </span>
  <span class="pl-v">sim</span> <span class="pl-k">=</span> study.strats.and.answers(
    <span class="pl-v">strats</span> <span class="pl-k">=</span> nlist(<span class="pl-smi">mix</span>),
    <span class="pl-v">strat.par</span> <span class="pl-k">=</span> <span class="pl-k">list</span>(<span class="pl-v">probC</span> <span class="pl-k">=</span> seq(<span class="pl-c1">0</span>,<span class="pl-c1">1</span>,<span class="pl-v">length</span><span class="pl-k">=</span><span class="pl-c1">11</span>)),
    <span class="pl-v">R</span><span class="pl-k">=</span><span class="pl-c1">50</span>, <span class="pl-v">delta</span><span class="pl-k">=</span><span class="pl-c1">0.95</span>, <span class="pl-v">sim</span><span class="pl-k">=</span><span class="pl-smi">sim</span>,<span class="pl-v">game</span><span class="pl-k">=</span><span class="pl-smi">game</span>
  )
  plot(<span class="pl-smi">sim</span>)</pre></div>

<p>Non-surprisingly, our strategy <strong>mix</strong> has the highest efficiency if probC=1, i.e. when it always cooperates. Yet, not only efficiency matters but also stability. Consider the following code:</p>

<div class="highlight highlight-r"><pre>  <span class="pl-v">sim</span> <span class="pl-k">=</span> <span class="pl-c1">NULL</span> <span class="pl-c"># reset sim</span>

  <span class="pl-c"># Study which mix variant is a best answer against mix with probC=1</span>
  <span class="pl-v">sim</span> <span class="pl-k">=</span> study.strats.and.answers(
    <span class="pl-v">strats</span> <span class="pl-k">=</span> nlist(<span class="pl-smi">mix</span>),<span class="pl-v">answers</span><span class="pl-k">=</span>nlist(<span class="pl-smi">mix</span>),
    <span class="pl-v">strat.par</span> <span class="pl-k">=</span> <span class="pl-k">list</span>(<span class="pl-v">probC</span> <span class="pl-k">=</span> <span class="pl-c1">1</span>),
    <span class="pl-v">answer.par</span> <span class="pl-k">=</span> <span class="pl-k">list</span>(<span class="pl-v">probC</span> <span class="pl-k">=</span> seq(<span class="pl-c1">0</span>,<span class="pl-c1">1</span>,<span class="pl-v">length</span><span class="pl-k">=</span><span class="pl-c1">11</span>)),
    <span class="pl-v">R</span><span class="pl-k">=</span><span class="pl-c1">50</span>, <span class="pl-v">delta</span><span class="pl-k">=</span><span class="pl-c1">0.95</span>, <span class="pl-v">sim</span><span class="pl-k">=</span><span class="pl-smi">sim</span>,<span class="pl-v">game</span><span class="pl-k">=</span><span class="pl-smi">game</span>
  )
  plot(<span class="pl-smi">sim</span>)</pre></div>

<p>The blue line shows the payoff of our strategy mix with probC=1. The red line shows the payoffs of candidates for best answers against the strategy mix with probC=1. Here the considered answer strategies are variants of mix with 11 different mixing probabilities between 0 and 1 (provided in the argument answer.par in the function call and shown on the x-axis of the plot.). Non-surprisingly, the strategy with mix=0 (i.e. always defect) achieves the highest payoff against our always.coop strategy and highly destabilizes it.</p>

<p>The following code studies payoffs and answer payoffs for 4 different mix-variants with probC = 0,0.1, 0.5 and 1.</p>

<div class="highlight highlight-r"><pre>  <span class="pl-v">sim</span> <span class="pl-k">=</span> <span class="pl-c1">NULL</span> <span class="pl-c"># reset sim</span>

  <span class="pl-c"># Study which mix variant is a best answer against mix with probC=1</span>
  <span class="pl-v">sim</span> <span class="pl-k">=</span> study.strats.and.answers(
    <span class="pl-v">strats</span> <span class="pl-k">=</span> nlist(<span class="pl-smi">mix</span>),<span class="pl-v">answers</span><span class="pl-k">=</span>nlist(<span class="pl-smi">mix</span>),
    <span class="pl-v">strat.par</span> <span class="pl-k">=</span> <span class="pl-k">list</span>(<span class="pl-v">probC</span> <span class="pl-k">=</span> c(<span class="pl-c1">0</span>,<span class="pl-c1">0.1</span>,<span class="pl-c1">0.5</span>,<span class="pl-c1">1</span>)),
    <span class="pl-v">answer.par</span> <span class="pl-k">=</span> <span class="pl-k">list</span>(<span class="pl-v">probC</span> <span class="pl-k">=</span> seq(<span class="pl-c1">0</span>,<span class="pl-c1">1</span>,<span class="pl-v">length</span><span class="pl-k">=</span><span class="pl-c1">11</span>)),
    <span class="pl-v">R</span><span class="pl-k">=</span><span class="pl-c1">50</span>, <span class="pl-v">delta</span><span class="pl-k">=</span><span class="pl-c1">0.95</span>, <span class="pl-v">sim</span><span class="pl-k">=</span><span class="pl-smi">sim</span>,<span class="pl-v">game</span><span class="pl-k">=</span><span class="pl-smi">game</span>
  )
  plot(<span class="pl-smi">sim</span>)
</pre></div>

<p>The plot shows the payoffs and answer payoff for all 4 variants of mix. In the plots for probC=0 and probC=0.1, you also see a green line. This is the <strong>score</strong> of the strategy computed from its efficiency and instability (see the rules of the tournament described earlier in this tutorial). For probC=0.5 and probC=1 the score is so strongly negative that it is not shown anymore in the plot. (Note that we don't have yet confidence intervals for the score.)</p>

<p>Our analysis confirms the idea that among different variants of mix, the variant with probC=0 (always defect) gets the highest score if we search for best answers also among different variants of mix.</p>

<p>Of course, "mix" is not a very clever class of strategies in the repeated prisoners' dilemma game. For example, tit.for.tat has the same efficiency as always.coop (mix for probC=1) while being much more stable. In the first problem set, you will be asked to consider a variant of the prisoners' dilemma where with probability err.D.prob an action "C" is wrongly observed as "D". This will make cooperation much harder to sustain and tit.for.tat loses its appeal quite quickly. We can also use the function study.strats.and.answers to explore the effect of changes in parameters of the game:</p>

<div class="highlight highlight-r"><pre>  <span class="pl-v">sim</span> <span class="pl-k">=</span> <span class="pl-c1">NULL</span> <span class="pl-c"># reset sim</span>

  <span class="pl-c"># Study which mix variant is a best answer against mix with probC=1</span>
  <span class="pl-v">sim</span> <span class="pl-k">=</span> study.strats.and.answers(
    <span class="pl-v">strats</span> <span class="pl-k">=</span> nlist(<span class="pl-smi">tit.for.tat</span>),<span class="pl-v">answers</span><span class="pl-k">=</span>nlist(<span class="pl-smi">mix</span>),
    <span class="pl-v">answer.par</span> <span class="pl-k">=</span> <span class="pl-k">list</span>(<span class="pl-v">probC</span> <span class="pl-k">=</span> seq(<span class="pl-c1">0</span>,<span class="pl-c1">1</span>,<span class="pl-v">length</span><span class="pl-k">=</span><span class="pl-c1">11</span>)),
    <span class="pl-v">R</span><span class="pl-k">=</span><span class="pl-c1">50</span>, <span class="pl-v">delta</span><span class="pl-k">=</span><span class="pl-c1">0.95</span>, <span class="pl-v">sim</span><span class="pl-k">=</span><span class="pl-smi">sim</span>,<span class="pl-v">game.fun</span><span class="pl-k">=</span><span class="pl-smi">make.pd.game</span>,
    <span class="pl-v">game.par</span> <span class="pl-k">=</span> <span class="pl-k">list</span>(<span class="pl-v">err.D.prob</span><span class="pl-k">=</span>c(<span class="pl-c1">0</span>,<span class="pl-c1">0.1</span>,<span class="pl-c1">0.3</span>))
  )
  plot(<span class="pl-smi">sim</span>)</pre></div>

<p>We see that tit-for-tat becomes less efficient and quite instable once we introduce the observation error. Interestingly, it is most strongly destabilized by the very cooperative variant of mix with probC=1.</p>

<p>Hope you enjoyed the tutorial. Have fun in the challenge that lie ahead! </p>
</article>
  </div>

</div>

<a href="#jump-to-line" rel="facebox[.linejump]" data-hotkey="l" style="display:none">Jump to Line</a>
<div id="jump-to-line" style="display:none">
  <form accept-charset="UTF-8" class="js-jump-to-line-form">
    <input class="linejump-input js-jump-to-line-field" type="text" placeholder="Jump to line&hellip;" autofocus>
    <button type="submit" class="btn">Go</button>
  </form>
</div>

        </div>

      </div><!-- /.repo-container -->
      <div class="modal-backdrop"></div>
    </div><!-- /.container -->
  </div><!-- /.site -->


    </div><!-- /.wrapper -->

      <div class="container">
  <div class="site-footer" role="contentinfo">
    <ul class="site-footer-links right">
        <li><a href="https://status.github.com/" data-ga-click="Footer, go to status, text:status">Status</a></li>
      <li><a href="https://developer.github.com" data-ga-click="Footer, go to api, text:api">API</a></li>
      <li><a href="https://training.github.com" data-ga-click="Footer, go to training, text:training">Training</a></li>
      <li><a href="https://shop.github.com" data-ga-click="Footer, go to shop, text:shop">Shop</a></li>
        <li><a href="https://github.com/blog" data-ga-click="Footer, go to blog, text:blog">Blog</a></li>
        <li><a href="https://github.com/about" data-ga-click="Footer, go to about, text:about">About</a></li>

    </ul>

    <a href="https://github.com" aria-label="Homepage">
      <span class="mega-octicon octicon-mark-github" title="GitHub"></span>
</a>
    <ul class="site-footer-links">
      <li>&copy; 2015 <span title="0.03410s from github-fe142-cp1-prd.iad.github.net">GitHub</span>, Inc.</li>
        <li><a href="https://github.com/site/terms" data-ga-click="Footer, go to terms, text:terms">Terms</a></li>
        <li><a href="https://github.com/site/privacy" data-ga-click="Footer, go to privacy, text:privacy">Privacy</a></li>
        <li><a href="https://github.com/security" data-ga-click="Footer, go to security, text:security">Security</a></li>
        <li><a href="https://github.com/contact" data-ga-click="Footer, go to contact, text:contact">Contact</a></li>
    </ul>
  </div>
</div>


    <div class="fullscreen-overlay js-fullscreen-overlay" id="fullscreen_overlay">
  <div class="fullscreen-container js-suggester-container">
    <div class="textarea-wrap">
      <textarea name="fullscreen-contents" id="fullscreen-contents" class="fullscreen-contents js-fullscreen-contents" placeholder=""></textarea>
      <div class="suggester-container">
        <div class="suggester fullscreen-suggester js-suggester js-navigation-container"></div>
      </div>
    </div>
  </div>
  <div class="fullscreen-sidebar">
    <a href="#" class="exit-fullscreen js-exit-fullscreen tooltipped tooltipped-w" aria-label="Exit Zen Mode">
      <span class="mega-octicon octicon-screen-normal"></span>
    </a>
    <a href="#" class="theme-switcher js-theme-switcher tooltipped tooltipped-w"
      aria-label="Switch themes">
      <span class="octicon octicon-color-mode"></span>
    </a>
  </div>
</div>



    
    

    <div id="ajax-error-message" class="flash flash-error">
      <span class="octicon octicon-alert"></span>
      <a href="#" class="octicon octicon-x flash-close js-ajax-error-dismiss" aria-label="Dismiss error"></a>
      Something went wrong with that request. Please try again.
    </div>


      <script crossorigin="anonymous" src="https://assets-cdn.github.com/assets/frameworks-d22b59d0085e83b7549ba4341ec9e68f80c2f29c8e49213ee182003dc8d568c6.js"></script>
      <script async="async" crossorigin="anonymous" src="https://assets-cdn.github.com/assets/github-0bc0f45c838b5d9d25bc071d2a4b0abe759a093392087dce55cd2caa00ea4f36.js"></script>
      
      

  </body>
</html>

